*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="upswiz.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS advanced AS baseform OF "basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Wizshape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOk" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkClustered" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgRemoteViews" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDefaultRemoteViewName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtRemViewExt" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDropTables" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: cancel		&& Specifies if a CommandButton is the Cancel button.
		*m: validated		&& validate form controls
		*m: writechanges		&& write changes to OEngine properties
		*p: droptables		&& Drop local tables after upsizing them?
		*p: oengine		&& A reference to an UpsizeEngine object
		*p: pkeyclustered		&& Make primary key a clustered index
		*p: remoteviewextension		&& Remote view name extension.
		*p: remoteviewpxsx		&& Remote view name prefix or suffix
	*</DefinedPropArrayMethod>

	BorderStyle = 2
	Caption = "Advanced Export Options"
	DoCreate = .T.
	Height = 183
	lsavesettings = .F.
	MaxButton = .F.
	MinButton = .F.
	Name = "advanced"
	oengine = .NULL.		&& A reference to an UpsizeEngine object
	Width = 420
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="cfoxuserid" type="property" display="cFoxUserID" favorites="True"/>
		<memberdata name="cfoxusername" type="property" display="cFoxUserName" favorites="True"/>
		<memberdata name="lpersistsizeposition" type="property" display="lPersistSizePosition" favorites="True"/>
		<memberdata name="lsavesettings" type="property" display="lSaveSettings" favorites="True"/>
		<memberdata name="opersist" type="property" display="oPersist"/>
		<memberdata name="refreshform" type="method" display="RefreshForm"/>
		<memberdata name="restoresettings" type="method" display="RestoreSettings" favorites="True"/>
		<memberdata name="savesettings" type="method" display="SaveSettings" favorites="True"/>
		<memberdata name="cleanup" type="method" display="Cleanup"/>
		<memberdata name="lrelease" type="property" display="lRelease"/>
		<memberdata name="releasemembers" type="method" display="ReleaseMembers"/>
		<memberdata name="oengine" type="property" display="oEngine"/>
		</VFPData>

	ADD OBJECT 'chkClustered' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Make primary key a \<clustered index", ;
		Left = 17, ;
		Name = "chkClustered", ;
		TabIndex = 2, ;
		Top = 30, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkDropTables' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Drop local tables", ;
		Left = 17, ;
		Name = "chkDropTables", ;
		TabIndex = 3, ;
		Top = 50, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdCancel' AS basecommandbutton WITH ;
		Cancel = .T., ;
		Caption = "Cancel", ;
		Left = 340, ;
		Name = "cmdCancel", ;
		TabIndex = 8, ;
		Top = 150, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdOk' AS basecommandbutton WITH ;
		Caption = "OK", ;
		Default = .T., ;
		Left = 340, ;
		Name = "cmdOk", ;
		TabIndex = 7, ;
		Top = 122, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lblDefaultRemoteViewName' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Default remote \<view name: ", ;
		Left = 16, ;
		Name = "lblDefaultRemoteViewName", ;
		Style = 3, ;
		TabIndex = 4, ;
		Top = 85, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblOptions' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Options: ", ;
		Left = 16, ;
		Name = "lblOptions", ;
		Style = 3, ;
		TabIndex = 1, ;
		Top = 10, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'opgRemoteViews' AS baseoptiongroup WITH ;
		BorderStyle = 1, ;
		ButtonCount = 3, ;
		Height = 82, ;
		Left = 10, ;
		Name = "opgRemoteViews", ;
		TabIndex = 5, ;
		Top = 92, ;
		Value = 1, ;
		Width = 304, ;
		ZOrderSet = 4, ;
		baseoptionbutton1.Caption = "\<Prefix", ;
		baseoptionbutton1.Left = 7, ;
		baseoptionbutton1.Name = "baseoptionbutton1", ;
		baseoptionbutton1.Top = 15, ;
		baseoptionbutton1.Value = 1, ;
		baseoptionbutton2.Caption = "\<Suffix", ;
		baseoptionbutton2.Left = 7, ;
		baseoptionbutton2.Name = "baseoptionbutton2", ;
		baseoptionbutton2.Top = 33, ;
		Baseoptionbutton3.Caption = "\<None (same as local table name)", ;
		Baseoptionbutton3.Left = 7, ;
		Baseoptionbutton3.Name = "Baseoptionbutton3", ;
		Baseoptionbutton3.Top = 50
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtRemViewExt' AS basetextbox WITH ;
		InputMask = "XXXXXXXX", ;
		Left = 86, ;
		Name = "txtRemViewExt", ;
		TabIndex = 6, ;
		Top = 118, ;
		Width = 113, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'Wizshape1' AS baseshape WITH ;
		Height = 58, ;
		Left = 10, ;
		Name = "Wizshape1", ;
		Style = 3, ;
		Top = 17, ;
		Width = 305, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />
	
	PROCEDURE cancel		&& Specifies if a CommandButton is the Cancel button.
		Thisform.Hide()
		
	ENDPROC

	PROCEDURE Init
		lparameters toExportOptions, ;
			toEngine
		dodefault()
		with Thisform
			.oEngine = toEngine
		
			* Enabled Advanced options based on Export options on calling page.
			.chkClustered.Enabled  = toExportOptions.chkIndexes.Value
			.chkDropTables.Enabled = toExportOptions.chkTableToView.Value
			.opgRemoteViews.BaseOptionButton1.Enabled = toExportOptions.chkTableToView.Value
			.opgRemoteViews.BaseOptionButton2.Enabled = toExportOptions.chkTableToView.Value
			.opgRemoteViews.BaseOptionButton3.Enabled = toExportOptions.chkTableToView.Value
		
			* Value Advanced option controls from OEngine
			.chkClustered.Value   = .oEngine.ExportClustered and .chkClustered.enabled 
			.chkDropTables.Value  = .oEngine.DropLocalTables and .chkDropTables.enabled
			.opgRemoteViews.Value = .oEngine.ViewPrefixOrSuffix
			.txtRemViewExt.Value  = .oEngine.ViewNameExtension
		endwith
		
	ENDPROC

	PROCEDURE QueryUnload
		Thisform.Cancel()
		nodefault
		
	ENDPROC

	PROCEDURE releasemembers
		This.oEngine = .NULL.
		
	ENDPROC

	PROCEDURE validated		&& validate form controls
		LOCAL llRetval, lcMessageText, loControl
		
		llRetval = .F.
		lcMessageText = ""
		loControl = Null
		
		DO CASE
			* Make sure extension if supplied if chose Prefix
			CASE EMPTY(thisform.txtRemViewExt.value) And thisform.opgRemoteViews.Value = 1 ;
					And thisform.txtRemViewExt.enabled
				lcMessageText = VIEW_NAME_PREFIX_REQD_LOC
				loControl = thisform.txtRemViewExt
			* Make sure extension if supplied if chose Suffix
			CASE EMPTY(thisform.txtRemViewExt.value) And thisform.opgRemoteViews.Value = 2 ;
					And thisform.txtRemViewExt.enabled
				lcMessageText = "You must supply a suffix for the view name, or choose None."
				loControl = thisform.txtRemViewExt
			* Make sure Suffix is not _local if not dropping tables (that's the default renaming suffix)
			CASE thisform.chkDropTables.Value = .F. And thisform.opgRemoteViews.Value = 2 And ;
				lower(Alltrim(thisform.txtRemViewExt.value)) = "_local"
				lcMessageText = "_local is the default suffix the Upsizng Wizard uses when renaming local tables. " + ;
									"You must either change this suffix or choose to Drop Local Tables."
				loControl = thisform.txtRemViewExt
			OTHERWISE
				llRetval = .T.
				* Provide gentle warning about dropping local tables
				IF thisform.chkDropTables.Value = .T.
					Thisform.oEngine.Alert ("You have chosen to Drop Local Tables! " + ;
									"You should make sure you have a recent backup of the local database before completing the Wizard.", 48)
				ENDIF	
		ENDCASE
		
		IF !llRetval
			Thisform.oEngine.Alert (lcMessageText, 48)
			loControl.SetFocus()
		ENDIF
		
		RETURN llRetval
	ENDPROC

	PROCEDURE writechanges		&& write changes to OEngine properties
		with Thisform
			* Write Advanced options to OEngine properties
			.oEngine.ExportClustered    = .chkClustered.Value 
			.oEngine.DropLocalTables    = .chkDropTables.Value
			.oEngine.ViewPrefixOrSuffix = .opgRemoteViews.Value 
			.oEngine.ViewNameExtension  = .txtRemViewExt.Value
		endwith
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		ThisForm.Cancel()
		
	ENDPROC

	PROCEDURE cmdOk.Click
		IF thisform.Validated()
			thisform.WriteChanges()
			thisform.hide()
		ENDIF
	ENDPROC

	PROCEDURE opgRemoteViews.InteractiveChange
		This.Parent.txtRemViewExt.Refresh()
	ENDPROC

	PROCEDURE txtRemViewExt.Refresh
		This.Enabled = not (This.Parent.opgRemoteViews.Value = 3 or ;
			not This.Parent.opgRemoteViews.BaseOptionButton1.Enabled)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cconnstr AS basewizardcontainer OF "basewizard.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="opgConnection" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgODBCType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtDatabase" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdGetDBC" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbConnections" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblConnections" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbDSN" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDSN" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDSNUserName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtDSNPassword" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDSNUserName" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDSNPassword" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmbServers" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblServers" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtServerUID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtServerPWD" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblServerUID" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblServerPWD" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="edtUserConnStr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkUseTC" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\upsizing.h"
	*<DefinedPropArrayMethod>
		*m: checkdriverversion
		*m: checkpermissionsora
		*m: checkpermissionssqs
		*m: getallserverdb
		*m: getallservers
		*m: getconnstr
		*m: getdbcconnections
		*m: getdbname
		*m: getdsns
		*m: getservertype
		*m: logoff
		*m: logon
		*m: refreshcontrols
		*m: servertype
		*m: sql_connect
		*p: clasterrormessage
		*p: coldconnstr
		*p: nconnectionstrtype		&& 1 - DBC Connection , 2 - Connection String
	*</DefinedPropArrayMethod>

	clasterrormessage = 
	coldconnstr = 
	Height = 343
	Name = "cconnstr"
	nconnectionstrtype = 0		&& 1 - DBC Connection , 2 - Connection String
	Width = 604
	_memberdata = <VFPData>
		<memberdata name="checkdriverversion" type="method" display="CheckDriverVersion"/>
		<memberdata name="checkpermissionsora" type="method" display="CheckPermissionsOra"/>
		<memberdata name="checkpermissionssqs" type="method" display="CheckPermissionsSqs"/>
		<memberdata name="clasterrormessage" type="property" display="cLastErrorMessage"/>
		<memberdata name="coldconnstr" type="property" display="cOldConnStr"/>
		<memberdata name="getallserverdb" type="method" display="GetAllServerDb"/>
		<memberdata name="getallservers" type="method" display="GetAllServers"/>
		<memberdata name="getconnstr" type="method" display="GetConnStr"/>
		<memberdata name="getdbcconnections" type="method" display="GetDbcConnections"/>
		<memberdata name="getdbname" type="method" display="GetDbName"/>
		<memberdata name="getdsns" type="method" display="GetDsns"/>
		<memberdata name="getservertype" type="method" display="GetServerType"/>
		<memberdata name="logoff" type="method" display="Logoff"/>
		<memberdata name="logon" type="method" display="Logon"/>
		<memberdata name="nconnectionstrtype" type="property" display="nConnectionStrType"/>
		<memberdata name="refreshcontrols" type="method" display="RefreshControls"/>
		<memberdata name="servertype" type="method" display="ServerType"/>
		<memberdata name="sql_connect" type="method" display="Sql_Connect"/>
		</VFPData>

	ADD OBJECT 'chkUseTC' AS basewizardcheckbox WITH ;
		Alignment = 0, ;
		Caption = "Use \<trusted connection", ;
		ControlSource = "Thisform.lTrustedConnection", ;
		Left = 314, ;
		Name = "chkUseTC", ;
		TabIndex = 15, ;
		Top = 194, ;
		ZOrderSet = 21
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmbConnections' AS basewizardcombobox WITH ;
		ControlSource = "Thisform.cConnection", ;
		Left = 90, ;
		Name = "cmbConnections", ;
		Style = 2, ;
		TabIndex = 5, ;
		Top = 60, ;
		Width = 181, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmbDSN' AS basewizardcombobox WITH ;
		ControlSource = "Thisform.cDSN", ;
		Left = 66, ;
		Name = "cmbDSN", ;
		Style = 2, ;
		TabIndex = 8, ;
		Top = 135, ;
		Width = 173, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmbServers' AS basewizardcombobox WITH ;
		ControlSource = "Thisform.cServer", ;
		Left = 110, ;
		lrefreshstepsonchange = .F., ;
		Name = "cmbServers", ;
		Style = 0, ;
		TabIndex = 14, ;
		Top = 190, ;
		Width = 173, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdGetDBC' AS basewizardcommandbutton WITH ;
		Caption = "...", ;
		Height = 22, ;
		Left = 500, ;
		Name = "cmdGetDBC", ;
		TabIndex = 3, ;
		Top = 36, ;
		Width = 22, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'edtDatabase' AS basewizardeditbox WITH ;
		ControlSource = "Thisform.cConnectionDatabase", ;
		Height = 21, ;
		IntegralHeight = .F., ;
		Left = 20, ;
		Name = "edtDatabase", ;
		TabIndex = 2, ;
		Top = 36, ;
		Width = 481, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="editbox" />

	ADD OBJECT 'edtUserConnStr' AS basewizardeditbox WITH ;
		ControlSource = "Thisform.cConnString", ;
		Height = 21, ;
		IntegralHeight = .F., ;
		Left = 35, ;
		Name = "edtUserConnStr", ;
		TabIndex = 22, ;
		Top = 295, ;
		Width = 559, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="editbox" />

	ADD OBJECT 'lblConnections' AS basewizardlabel WITH ;
		Caption = "\<Connection", ;
		Left = 20, ;
		Name = "lblConnections", ;
		TabIndex = 4, ;
		Top = 64, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblDSN' AS basewizardlabel WITH ;
		Caption = "\<DSN", ;
		Left = 35, ;
		Name = "lblDSN", ;
		TabIndex = 7, ;
		Top = 139, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblDSNPassword' AS basewizardlabel WITH ;
		Caption = "\<Password", ;
		Left = 430, ;
		Name = "lblDSNPassword", ;
		TabIndex = 11, ;
		Top = 139, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblDSNUserName' AS basewizardlabel WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "\<User name", ;
		Height = 15, ;
		Left = 250, ;
		Name = "lblDSNUserName", ;
		TabIndex = 9, ;
		Top = 139, ;
		Width = 53, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblServerPWD' AS basewizardlabel WITH ;
		Caption = "P\<assword", ;
		Left = 35, ;
		Name = "lblServerPWD", ;
		TabIndex = 18, ;
		Top = 244, ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblServers' AS basewizardlabel WITH ;
		Caption = "\<Server name", ;
		Left = 35, ;
		Name = "lblServers", ;
		TabIndex = 13, ;
		Top = 194, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblServerUID' AS basewizardlabel WITH ;
		Caption = "Us\<er name", ;
		Left = 35, ;
		Name = "lblServerUID", ;
		TabIndex = 16, ;
		Top = 219, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'opgConnection' AS basewizardoptiongroup WITH ;
		ButtonCount = 2, ;
		ControlSource = "Thisform.nConnectionType", ;
		Height = 356, ;
		Left = -5, ;
		Name = "opgConnection", ;
		TabIndex = 1, ;
		Top = 12, ;
		Value = 2, ;
		Width = 610, ;
		ZOrderSet = 0, ;
		baseoptionbutton1.Caption = "Use database connect\<ion", ;
		baseoptionbutton1.Left = 5, ;
		baseoptionbutton1.Name = "baseoptionbutton1", ;
		baseoptionbutton1.Top = 5, ;
		baseoptionbutton1.Value = 0, ;
		baseoptionbutton2.Caption = "\<ODBC", ;
		baseoptionbutton2.Left = 5, ;
		baseoptionbutton2.Name = "baseoptionbutton2", ;
		baseoptionbutton2.Top = 80, ;
		baseoptionbutton2.Value = 1
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'opgODBCType' AS basewizardoptiongroup WITH ;
		ButtonCount = 3, ;
		ControlSource = "Thisform.nODBCType", ;
		Height = 219, ;
		Left = 10, ;
		Name = "opgODBCType", ;
		TabIndex = 6, ;
		Top = 111, ;
		Value = 1, ;
		Width = 588, ;
		ZOrderSet = 1, ;
		baseoptionbutton1.Caption = "Use DS\<N", ;
		baseoptionbutton1.Left = 5, ;
		baseoptionbutton1.Name = "baseoptionbutton1", ;
		baseoptionbutton1.Top = 4, ;
		baseoptionbutton1.Value = 1, ;
		baseoptionbutton2.Caption = "\<Generate SQL connection string", ;
		baseoptionbutton2.Left = 5, ;
		baseoptionbutton2.Name = "baseoptionbutton2", ;
		baseoptionbutton2.Top = 59, ;
		baseoptionbutton2.Value = 0, ;
		Baseoptionbutton3.Caption = "Use connection st\<ring", ;
		Baseoptionbutton3.Left = 5, ;
		Baseoptionbutton3.Name = "Baseoptionbutton3", ;
		Baseoptionbutton3.Top = 164
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtDSNPassword' AS basewizardtextbox WITH ;
		ControlSource = "Thisform.cDSNPassword", ;
		Left = 487, ;
		lrefreshstepsonchange = .F., ;
		Name = "txtDSNPassword", ;
		PasswordChar = "*", ;
		TabIndex = 12, ;
		Top = 135, ;
		Width = 109, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtDSNUserName' AS basewizardtextbox WITH ;
		ControlSource = "Thisform.cDSNUserName", ;
		Left = 309, ;
		lrefreshstepsonchange = .F., ;
		Name = "txtDSNUserName", ;
		TabIndex = 10, ;
		Top = 135, ;
		Width = 109, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtServerPWD' AS basewizardtextbox WITH ;
		ControlSource = "Thisform.cServerPassword", ;
		Left = 110, ;
		lrefreshstepsonchange = .F., ;
		Name = "txtServerPWD", ;
		PasswordChar = "*", ;
		TabIndex = 19, ;
		Top = 240, ;
		Width = 173, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtServerUID' AS basewizardtextbox WITH ;
		ControlSource = "Thisform.cServerUserName", ;
		Left = 110, ;
		Name = "txtServerUID", ;
		TabIndex = 17, ;
		Top = 215, ;
		Width = 173, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="textbox" />
	
	PROCEDURE checkdriverversion
		LOCAL lnRetVal, lnODBCEnv, lnhdbc, lcVersion, lnBytes
		
		#DEFINE SQL_DRIVER_VER			7
		*Earliest possible SQL 95 driver version is "02.05.0085"
		*Previous version is "02.00.1912"
		
		*This routine returns true if the version is 2.05 or later
		
		IF !Thisform.oEngine.ServerType == "SQL Server95" THEN
			RETURN .T.
		ENDIF
		
		lnODBCEnv=VAL(SYS(3053))
		lcVersion=space(20)
		lnBytes=0
		
		declare short SQLGetInfo IN odbc32 Integer hdbc, Integer fInfoType, ;
			string @ lcVersion, Integer cbInfoValueMax, Integer @ lnBytes
		
		lnHDBC=sqlgetprop(Thisform.oEngine.MasterConnHand,"ODBChdbc")
		
		lnRetVal=SQLGetInfo(lnHDBC,SQL_DRIVER_VER,@lcVersion,50,@lnBytes)
		
		IF VAL(LEFT(m.lcVersion,5))>=2.05
			RETURN .T.
		ELSE
			WAIT CLEAR
			=MESSAGEBOX(NEED_SQL6DRVR_LOC,ICON_EXCLAMATION,TITLE_TEXT_LOC)
			RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE checkpermissionsora
		*Here checking to see the user can create tablespaces, tables, clusters,triggers and procs
		
		LOCAL lcErrMsg, lcSQL, lnOldArea, lnRetVal, lnRetVal, ;
			 aPerm, lcCRLF, llRetVal, lcSQL
			
		lcCRLF=CHR(10)+CHR(13)
		
		*Set permissions to false, then flip them true as appropriate
		with Thisform.oEngine
			.Perm_Table		=	.F.
			.Perm_AltTS		=	.F.
			.Perm_Sproc		=	.F.
			.Perm_CreaTS		=	.F.
			.Perm_Trigger	=	.F.
			.Perm_UnlimTS	=	.F.
			.Perm_Cluster	=	.F.
			.Perm_Index		=	.F.
		endwith
		*See if this is Oracle 6 or Oracle 7
		*Oracle 6 doesn't allow comments in queries so this will fail
		*if user connected to Oracle 6
		
		IF Thisform.oEngine.ServerVer = 6.00 THEN
			=MESSAGEBOX(ORA_NOT_COOL_LOC, ICON_EXCLAMATION, TITLE_TEXT_LOC)
			RETURN .F.
		ENDIF
		
		* determine the system priviliges for curent user
			lcsql = "Select * from SESSION_PRIVS"
			IF Thisform.oEngine.ExecuteTempSPT(lcSQL) 
				SCAN
				DO CASE
					CASE Sqlresult.privilege = 'ALTER TABLESPACE'
						Thisform.oEngine.Perm_AltTS = .T.
					CASE Sqlresult.privilege = 'CREATE TABLESPACE'
						Thisform.oEngine.Perm_CreaTS = .T.
					CASE Sqlresult.privilege = 'UNLIMITED TABLESPACE'
						Thisform.oEngine.Perm_UnlimTS = .T.
					CASE Sqlresult.privilege = 'CREATE CLUSTER'
						Thisform.oEngine.Perm_Cluster = .T.
					CASE Sqlresult.privilege = 'CREATE PROCEDURE'
						Thisform.oEngine.Perm_Sproc = .T.
					CASE Sqlresult.privilege = 'CREATE TABLE'
						Thisform.oEngine.Perm_Table = .T.
					CASE Sqlresult.privilege = 'CREATE TRIGGER'
						Thisform.oEngine.Perm_Trigger = .T.
					CASE Sqlresult.privilege = 'CREATE ANY INDEX'
						Thisform.oEngine.Perm_Index = .T.
		
				ENDCASE
				ENDSCAN	
				ELSE
			=MESSAGEBOX(CANT_PERMISSION_LOC,ICON_EXCLAMATION,TITLE_TEXT_LOC)
			with Thisform.oEngine
				.Perm_Table		=	.T.
				.Perm_AltTS		=	.T.
				.Perm_Sproc		=	.T.
				.Perm_CreaTS		=	.T.
				.Perm_Trigger	=	.T.
				.Perm_UnlimTS	=	.T.
				.Perm_Cluster	=	.T.
				.Perm_Index		=	.T.
			endwith
			RETURN
			ENDIF	
		
		lcErrMsg=""
		IF !Thisform.oEngine.Perm_CreaTS
			lcErrMsg=CANT_CREATE_TABLESPACE_LOC
		ENDIF
		
		IF !Thisform.oEngine.Perm_AltTS
			IF !EMPTY(lcErrMsg)
				lcErrMsg= lcErrMsg + ", "
			ENDIF
			lcErrMsg=lcErrMsg+CANT_ALTER_TABLESPACE_LOC
		ENDIF
		
		IF !Thisform.oEngine.Perm_Table THEN
			IF !EMPTY(lcErrMsg)
				lcErrMsg= lcErrMsg + ", "
			ENDIF
			lcErrMsg=lcErrMsg+CANT_CREATE_OTABLE_LOC
		ENDIF 
		IF !Thisform.oEngine.Perm_UnlimTS
			IF !EMPTY(lcErrMsg)
				lcErrMsg= lcErrMsg + ", "
			ENDIF
			lcErrMsg=lcErrMsg + CANT_UNLIMITED_TS_LOC
		ENDIF
		
		IF !Thisform.oEngine.Perm_Cluster
			IF !EMPTY(lcErrMsg)
				lcErrMsg= lcErrMsg + ", "
			ENDIF
			lcErrMsg=lcErrMsg + CANT_CREATE_OCLUST_LOC
		ENDIF
		
		IF !Thisform.oEngine.Perm_Index 
			IF !EMPTY(lcErrMsg)
				lcErrMsg=lcErrMsg+ ", "
			ENDIF
			lcErrMsg=lcErrMsg+CANT_CREATE_ORAINDEX_LOC
		ENDIF
		
		IF !Thisform.oEngine.Perm_Trigger
			IF !EMPTY(lcErrMsg) 
				lcErrMsg=lcErrMsg+ ", "
			ENDIF
			lcErrMsg=lcErrMsg+CANT_CREATE_TRIGGER_LOC
		ENDIF
		
		IF !Thisform.oEngine.Perm_Sproc
			IF !EMPTY(lcErrMsg) 
				lcErrMsg=lcErrMsg+ ", "
			ENDIF
			lcErrMsg=lcErrMsg+CANT_CREATE_OPROC_LOC
		ENDIF
		
		
		IF !EMPTY(lcErrMsg) THEN
			lcErrMsg=LACKING_PERMS_ORA + lcErrMsg + "."
			=MESSAGEBOX(lcErrMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
		ENDIF
		
	ENDPROC

	PROCEDURE checkpermissionssqs
		*This method gets userid and username, checks to see if the
		*user is 'sa'
		
		LOCAL lnRetVal
		
		*Use the master database
		IF lower(rtrim(Thisform.oEngine.ServerDBName))<>"master" THEN
			IF !Thisform.oEngine.ExecuteTempSPT("use master") THEN
				*If the user can't use master
				*they can just try their luck creating stuff
				RETURN
			ENDIF
		ENDIF
		
		*Get user name and id
		lcUserName=""
		lnUserID=0
		lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_NAME()",@lcUserName,"Exp")
		Thisform.oEngine.UserName=lcUserName
		lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_ID()",@lnUserID,"Exp")
		Thisform.oEngine.UserID=lnUserID
		
		*If the user is sa, they can create devices
		Thisform.oEngine.Perm_Device=IIF(Thisform.oEngine.UserID=1,.T.,.F.)
	ENDPROC

	PROCEDURE getallserverdb
		LOCAL lcConnectionStr, lcTemAlias as String
		LOCAL lnConnectionHandle, lnOK, lnOldWorkArea as Integer
		
		
		WITH This
			.cmbDatabases.Clear()
			lcConnectionStr = .Getconnstr()
			IF !EMPTY(lcConnectionStr)
		
				lnConnectionHandle = This.SQL_Connect(lcConnectionStr,1)
				
				IF lnConnectionHandle  > 0
					lcTemAlias = SYS(2015)
					lnOldWorkArea = SELECT()
					lnOK = SQLEXEC(lnConnectionHandle,"sp_databases",lcTemAlias)
					IF lnOK > 0
						SELECT(lcTemAlias)
						SCAN
							.cmbDatabases.AddItem(ALLTRIM(DataBase_Name))
						ENDSCAN
					ENDIF
					IF USED(lcTemAlias)
						USE IN (lcTemAlias)
					ENDIF
					SELECT(lnOldWorkArea)
					SQLDISCONNECT(lnConnectionHandle)
				ENDIF
			ENDIF
			.cmbDatabases.Requery()
		ENDWITH
	ENDPROC

	PROCEDURE getallservers
		LOCAL lServersString[1,1], lerrorString[1,1], Names_Data, get_ser
		
		lServersString[1,1] = ""
		lerrorString[1,1] = ""
		
		Wait WINDOW "Retrieving SQL Server information" NOWAIT NoClear
		
		get_ser = GetSQLServers(@lServersString, @lerrorString)
		Names_Data = STRTRAN(lServersString, ',', Chr(13)+Chr(10))
		
		WITH THIS.cmbServers as ComboBox
			.Clear()
		
			For i = 1 To Memlines(Names_Data)
				.AddListItem(ALLTRIM(Mline(Names_Data, i)))
			ENDFOR
		
			IF .ListCount > 0
				.ListIndex = 1
			ENDIF
		ENDWITH
		
		WAIT CLEAR
	ENDPROC

	PROCEDURE getconnstr
		LOCAL lcConnectionString, lcConnectionName, lcDBCName, lcOldDatabase as String
		LOCAL llUseDBCConnection as Logical
		LOCAL loException as Exception
		LOCAL lnErrorNo, lnODBCType as Integer
		
		lcConnectionString = ""
		
		WITH This
			llUseDBCConnection = (.opgConnection.Value = 1)
			
			IF llUseDBCConnection
			* Use cannection from database
				lcConnectionString = ALLTRIM(.cmbConnections.Value)
				.nConnectionstrtype = 1
			ELSE
			* Use ODBC
				.nConnectionstrtype = 2
				lnODBCType = .opgODBCType.Value
				DO CASE
					CASE lnODBCType = 1 && DSN
						IF !EMPTY(.cmbDSN.Value)
							lcConnectionString = "DSN=" + ALLTRIM(.cmbDSN.Value)
							IF !EMPTY(.txtDSNUserName.Value)
								lcConnectionString = lcConnectionString + ";UID=" + ALLTRIM(.txtDSNUserName.Value)
							ENDIF
							IF ! EMPTY(.txtDSNPassword.Value)
								lcConnectionString = lcConnectionString + ";PWD=" + ALLTRIM(.txtDSNPassword.Value)
							ENDIF
						ENDIF 
					CASE lnODBCType = 2 && Server
						IF !EMPTY(.cmbServers.DisplayValue)
							lcConnectionString = "DRIVER={SQL SERVER};SERVER=" + ALLTRIM(.cmbServers.DisplayValue)
							IF .chkUseTC.Value && Use Trusted Connection
								lcConnectionString = lcConnectionString + ";Trusted_Connection=YES"
							ELSE
								IF !EMPTY(.txtServerUID.Value)
									lcConnectionString = lcConnectionString + ";UID=" + ALLTRIM(.txtServerUID.Value)
								ENDIF
								IF !EMPTY(.txtServerPWD.Value)
									lcConnectionString = lcConnectionString + ";PWD=" + ALLTRIM(.txtServerPWD.Value)	
								ENDIF
							ENDIF
						ENDIF
					CASE lnODBCType = 3 && User Write Connection string
						lcConnectionString = ALLTRIM(.edtUserConnStr.Value)
				ENDCASE
			ENDIF
			.cOldconnstr = lcConnectionString
		ENDWITH
		
		RETURN lcConnectionString
	ENDPROC

	PROCEDURE getdbcconnections
		LPARAMETERS tcDBCName
		
		LOCAL lcOldDatabase, laDBCConnection[1,1] as String
		LOCAL loException as Exception
		LOCAL lnErrorNo, lnConnectionCount, lnConnIndex as Integer
		
		This.cmbConnections.Clear()
		
		IF !DBUSED(tcDBCName)
			lnErrorNo = 0
			TRY
				OPEN DATABASE (tcDBCName)
			CATCH TO loException
				lnErrorNo = loException.ErrorNo
			ENDTRY
			IF lnErrorNo > 0
				=MESSAGEBOX("Cannot open database " + lcDBCPathName,0 + 64,ThisForm.Caption)
				RETURN .f.
			ENDIF
		ENDIF
		
		IF DBUSED(tcDBCName)
			lcOldDatabase = SET("Database")
			SET DATABASE TO (tcDBCName)
			lnConnectionCount = 0
			lnConnectionCount = ADBOBJECTS(laDBCConnection,"CONNECTION")
			IF lnConnectionCount > 0
				FOR lnConnIndex = 1 TO lnConnectionCount
					This.cmbConnections.AddItem(laDBCConnection[lnConnIndex])
				ENDFOR
				This.cmbConnections.ListIndex = 1
			ELSE
				=MESSAGEBOX("There are no connections in the selected Database.",0 + 64,ThisForm.Caption)
			ENDIF
			SET DATABASE TO (lcOldDatabase)
		ENDIF
	ENDPROC

	PROCEDURE getdbname
		LOCAL lcSQL, lcDBName, llOne
		
			* only for SOL server (AT-12/10/95)
		lcSQL="SELECT DB_NAME()"
		lcDBName=""
		Thisform.oEngine.SingleValueSPT(lcSQL, @lcDBName, "Exp", llOne)
			
		RETURN lcDBName
		
	ENDPROC

	PROCEDURE getdsns
		LOCAL lnDataSourcesNum, laDSN[1,1], kk
		
		lnDataSourcesNum = 0
		
		This.cmbDSN.Clear()
		lnDataSourcesNum = AODBCDataSources(@laDSN)
		IF lnDataSourcesNum > 0
			asort(laDSN, -1, -1, 0, 1)
			FOR kk = 1 TO lnDataSourcesNum
				This.cmbDSN.AddItem(laDSN[kk,1])
			ENDFOR
			This.cmbDSN.ListIndex = 1
		ENDIF
		
		RETURN lnDataSourcesNum
	ENDPROC

	PROCEDURE getservertype
		local lcServerType, lnRetVal
		lcServerType = ""
		
		declare short SQLGetInfo IN odbc32 Integer hdbc,Integer fInfoType,String @cName,;
				Integer cNameMax, Integer @cbName
		
		*Start ODBC
		hdbc = sqlgetprop(Thisform.oEngine.MasterConnHand, "ODBChdbc")
				
		*Do until all the data source names have been retrieved
		cName = space(128)
		cbName = 0
		
		lnRetVal = sqlgetinfo(hdbc, SQL_DBMS_NAME, @cName, 128, @cbName)
		
		IF lnRetVal = SQL_SUCCESS THEN		&&if no error occurred
			cName = UPPER(LEFT(cName, AT(CHR(0), cName)-1))
			lcServerType = this.ServerType(cName)
		ENDIF
			
		IF lcServerType <> IIF(Thisform.oEngine.SqlServer, SQL_SERVER, ORACLE_SERVER)
			lcMsg = STRTRAN(INVALID_SERVER_LOC, "|1", cName)
			=MESSAGEBOX(lcMsg, ICON_EXCLAMATION, TITLE_TEXT_LOC)
			RETURN .F.
		ENDIF
		
		Thisform.oEngine.CurrentServerType = lcServerType
		Thisform.oEngine.ServerType = lcServerType
		
		* get server version
		cName = space(128)
		cbName = 0
		
		lnRetVal = sqlgetinfo(hdbc, SQL_DBMS_VER, @cName, 128, @cbName)
		IF lnRetVal # SQL_SUCCESS 		&&if no error occurred
			RETURN
		ENDIF
		
		* parses the version string 'vv.MM.mmmm' and returns the value for 'vv.MM'
		cName = LEFT(cName, AT(CHR(0), cName)-1)
			
		* actual server version or 0
		Thisform.oEngine.ServerVer = VAL(cName)
		
		*See what version of SQL Server they're using
		IF Thisform.oEngine.SqlServer
			DO CASE
			CASE Thisform.oEngine.ServerVer < 4
				*Old unsupported SQL Server
				=MESSAGEBOX(VERS_NOT_SUPPORTED_LOC,ICON_EXCLAMATION,TITLE_TEXT_LOC)
				RETURN .F.
			CASE Thisform.oEngine.ServerVer < 6
				*4.x is cool
				Thisform.oEngine.ServerType = "SQL Server"
			CASE Thisform.oEngine.ServerVer >= 6
				*New and improved SQL Server
				Thisform.oEngine.ServerType = "SQL Server95"	
			ENDCASE
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		This.RefreshControls()
		This.opgODBCType.Value = This.opgODBCType.Value
		
	ENDPROC

	PROCEDURE logoff
		local lcDataSourceName, ;
			lcDataSourceType, ;
			i, ;
			lnUserInput, ;
			lcConnection, ;
			lcExact
		
		* If the user made device decisions, warn them that these will go. Otherwise,
		* just do it.
		
		if Thisform.oEngine.DeviceLogChosen or Thisform.oEngine.DeviceDBChosen or ;
			Thisform.oEngine.GridFilled
			lnUserInput = messagebox(DELETE_DEVICE_INFO_LOC, ICON_EXCLAMATION + ;
				YES_NO_BUTTONS, TITLE_TEXT_LOC)
		else
			lnUserInput = USER_YES
		endif
		
		*Reset stuff if OK with user or nothing lost (no device decisions made)
		
		IF lnUserInput=USER_YES
			Thisform.oEngine.DeviceCleanUp()
			Thisform.oEngine.GridFilled = .F.
			*Make sure we aren't getting tons of open connections if the user comes back and changes the datasource
			IF Thisform.oEngine.MasterConnHand<>0 THEN
				TRY
					SQLDISCONN(Thisform.oEngine.MasterConnHand)
				CATCH
				ENDTRY
				Thisform.oEngine.MasterConnHand=0
			ENDIF
			RETURN .T.
		ELSE
			*Set the user's choice back and prevent move to next page
			this.ResetChoices
			RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE logon
		LOCAL lcPartialConnectString, lnDsIndex, lcDataSourceName, ;
			  lcUserName, lnUserID, lcServerType, lcExact, lcMsg, lcConnectDB
			
		LOCAL lcConnStr
		
		lcExact = SET('EXACT')
		SET EXACT ON
		
		WAIT CHECK_PERMS_LOC WINDOW NOWAIT
		
		Thisform.oEngine.DataSourceName = ""
		
		Thisform.oEngine.MasterConnHand = 0
		lcConnStr = This.GetConnStr()
		IF this.opGCONNECTION.Value = 1
			IF EMPTY(lcConnStr)
				=MESSAGEBOX("There are no connections in the selected Database.",0 + 64,ThisForm.Caption)
				RETURN .F.
			ENDIF
			Thisform.oEngine.UserConnection = lcConnStr
			Thisform.oEngine.MasterConnHand = This.SQL_Connect(lcConnStr, 0)
		ELSE
			IF This.opGODBCTYPE.Value = 1 ;&& DSN
				And This.cmbDSN.ListCount > 0 and This.cmbDSN.ListIndex > 0
		
				Thisform.oEngine.DataSourceName = This.cmBDSN.Value
			ENDIF
			Thisform.oEngine.MasterConnHand = This.SQL_Connect(lcConnStr, 1)
		ENDIF
		
		IF !Thisform.oEngine.UserConnection=="" THEN
			Thisform.oEngine.PwdInDef=!EMPTY(DBGETPROP(Thisform.oEngine.UserConnection,"connection","password"))
		ELSE
			Thisform.oEngine.PwdInDef=.F.
		ENDIF
		
		SET EXACT &lcExact
		
		DO CASE
			CASE Thisform.oEngine.MasterConnHand = -1
				* connection failure
		*!*			THISFORMSET.refreshsteps
				lcMsg = This.cLastErrorMessage
				=MESSAGEBOX(lcMsg, ICON_EXCLAMATION, TITLE_TEXT_LOC)
				WAIT CLEAR
				RETURN .F.
		
			CASE Thisform.oEngine.MasterConnHand = -2
				* invalid conn. handle (rare)
		*!*			THISFORMSET.refreshsteps
				lcMsg = STRTRAN(SQLCONN_FAIL_LOC, "|1", lcDataSourceName)
				=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
				Thisform.oEngine.DataSourceChosen  = .F.
				WAIT CLEAR
				RETURN .F.
		ENDCASE
		
		*Set properties of the connection in case the user has weird settings
		Thisform.oEngine.ConnectString = SQLGETPROP(Thisform.oEngine.MasterConnHand,"connectstring")
		Thisform.oEngine.SetConnProps()
		*!*	this.getUserName
		
		* check the actual server type (SQL_SERVER or ORACLE_SERVER) and get server version
		lcServerType = Thisform.oEngine.ServerType	&& previous server type
		IF !this.getServerType()
			WAIT CLEAR
			RETURN .F.
		ENDIF
		
		* If the user changes the server type, some recalculations need to be made
		IF !lcServerType == Thisform.oEngine.ServerType THEN
			IF !Thisform.oEngine.EnumTablesTbl == "" THEN
				lnOldArea=SELECT()
				SELECT (Thisform.oEngine.EnumTablesTbl)
				REPLACE ALL FldsAnald with .F.
				* need new fields and mapping table
				Thisform.oEngine.EnumFieldsTbl = ""
				Thisform.oEngine.MappingTable = ""
				SELECT (lnOldArea)
			ENDIF
			Thisform.oEngine.AnalyzeFieldsRecalc=.T.
		ENDIF
		
		IF Thisform.oEngine.SqlServer
			*Figure out what database the user connected to
			Thisform.oEngine.ServerDBName=Thisform.oEngine.ParseConnectString(Thisform.oEngine.ConnectString,"database=")
			
			*See what db we're actually connected to; the database user expects 
			*to log into might no longer exist.  Or the user might have connected
			*with a DSN which doesn't specify a database
			lcConnectDB=this.GetDBName()
			*IF DSN doesn't specify database, see what we're connected to and
			*make that the target database
			IF Thisform.oEngine.ServerDBName==""
				Thisform.oEngine.ServerDBName=lcConnectDB
			ENDIF
		
			*If the connectdb and DSN-specified DB differ, that's fine if we're
			*not using a connection; a connection with a DB that doesn't exist is bad
			IF !LOWER(RTRIM(lcConnectDB))==LOWER(RTRIM(Thisform.oEngine.ServerDBName))
				IF Thisform.oEngine.UserConnection==""
					Thisform.oEngine.ServerDBName=lcConnectDB
				ELSE
					lcMsg=STRTRAN(DB_GONE_LOC,"|1",Thisform.oEngine.ServerDBName)
					=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)	
					WAIT CLEAR
					RETURN .F.
				ENDIF		
			ENDIF
		ELSE
			* Figure out what database the user connected to
			Thisform.oEngine.ServerDBName = Thisform.oEngine.ParseConnectString(Thisform.oEngine.ConnectString,"dbq=")
		ENDIF
		
		WAIT CHECK_PERMS_LOC WINDOW NOWAIT
		
		IF Thisform.oEngine.SqlServer
			*User may have logged into a 1.x server
			IF !this.CheckPermissionsSQS() or !this.CheckDriverVersion()
				WAIT CLEAR
				RETURN .F.
			ENDIF
		ELSE
			*User may have logged into an Oracle 6 server
			IF !this.CheckPermissionsORA()
				WAIT CLEAR
				RETURN .F.
			ENDIF
		ENDIF
		WAIT CLEAR
		
		Thisform.oEngine.DataSourceChosen = .T.
	ENDPROC

	PROCEDURE refreshcontrols
		LOCAL llDBCConnection as Logical
		LOCAL lnODBCType as Integer
		
		WITH This
			llDBCConnection = (.opgConnection.Value = 1)
			lnODBCType = .opgODBCType.Value
			
			* DBC Connections 
			.edtDatabase.Enabled = llDBCConnection
			.cmdGetDBC.Enabled = llDBCConnection
			.cmbConnections.Enabled = llDBCConnection
			.lblConnections.Enabled = llDBCConnection
		
			* ODBC
			.opgODBCType.Enabled = not llDBCConnection
		
			* DSN
			.cmbDSN.Enabled = (lnODBCType = 1) and !llDBCConnection
			.lblDSN.Enabled = .cmbDSN.Enabled
			.txtDSNPassword.Enabled = .cmbDSN.Enabled
			.lblDSNPassword.Enabled = .cmbDSN.Enabled
			.txtDSNUserName.Enabled = .cmbDSN.Enabled
			.lblDSNUserName.Enabled = .cmbDSN.Enabled
		
			* Sever
			.cmbServers.Enabled = (lnODBCType = 2) and !llDBCConnection
			.lblServers.Enabled = .cmbServers.Enabled
			.txtServerUID.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
			.lblServerUID.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
			.txtServerPWD.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
			.lblServerPWD.Enabled = .cmbServers.Enabled and !.chkUseTC.Value
			.chkUseTC.Enabled = .cmbServers.Enabled
					
			* User Write connection string
			.edtUserConnStr.Enabled = (lnODBCType = 3)
		ENDWITH
	ENDPROC

	PROCEDURE servertype
		PARAMETER lcServerName
		LOCAL lcServerType
		
		DO CASE
		CASE ATC("SQL Server",lcServerName) <> 0
			lcServerType = SQL_SERVER
		CASE ATC("Oracle", lcServerName) <> 0
			lcServerType = ORACLE_SERVER
		CASE ATC("Microsoft", lcServerName) <> 0
			lcServerType = MS_SERVER
		OTHERWISE
			lcServerType = UNKNOWN_SERVER
		ENDCASE
		
		RETURN lcServerType
			
		
	ENDPROC

	PROCEDURE sql_connect
		LPARAMETERS tcConnectionStr as String, tnConnectionStrType as Integer && 0 - SQLConnect, 1 - SQLStringConnect
		
		LOCAL lnConnHand, lnConnStrType as Integer
		LOCAL lOldDispLogin
		
		lnConnHand = -1
		lnConnStrType = 1
		This.cLastErrorMessage = ""
		
		IF VARTYPE(tcConnectionStr) # "C" OR EMPTY(tcConnectionStr)
			This.cLastErrorMessage = "Invalid connection string"
			RETURN lnConnHand
		ENDIF
		
		IF VARTYPE(tnConnectionStrType) = "N" AND BETWEEN(tnConnectionStrType,0,1)
			lnConnStrType = tnConnectionStrType 
		ENDIF
		
		lOldDispLogin = SQLGETPROP(0,"DispLogin")
		SQLSETPROP(0,"DispLogin",3)
		
		IF lnConnStrType = 1
			lnConnHand = SQLSTRINGCONNECT(tcConnectionStr)
		ELSE
			lnConnHand = SQLCONNECT(tcConnectionStr)
		ENDIF
		
		IF lnConnHand = -1
			This.cLastErrorMessage = MESSAGE()
		ENDIF
		
		SQLSETPROP(0,"DispLogin",lOldDispLogin)
		
		RETURN lnConnHand
		
		
	ENDPROC

	PROCEDURE chkUseTC.InteractiveChange
		dodefault()
		This.Parent.Refreshcontrols()
	ENDPROC

	PROCEDURE cmbServers.Valid
		if not This.DisplayValue == This.Value
			This.AddListItem(This.DisplayValue)
			This.Value = This.DisplayValue
		endif not This.DisplayValue == This.Value
		
	ENDPROC

	PROCEDURE cmdGetDBC.Click
		LOCAL lcDBCPathName
		
		lcDBCPathName = GETFILE("DBC")
		
		IF !EMPTY(lcDBCPathName)
			This.Parent.edtDatabase.Value = lcDBCPathName
			This.Parent.GEtdbcconnections(lcDBCPathName)	
		ENDIF
	ENDPROC

	PROCEDURE edtDatabase.LostFocus
		This.Value = chrtran(This.Value, chr(13) + chr(10), '')
		
	ENDPROC

	PROCEDURE edtDatabase.Valid
		IF !(This.Tag == UPPER(ALLTRIM(This.Value))) AND !EMPTY(This.Value)
			This.Parent.GEtdbcconnections(This.Value)
		ENDIF
	ENDPROC

	PROCEDURE edtDatabase.When
		This.Tag = UPPER(ALLTRIM(This.Value))
	ENDPROC

	PROCEDURE edtUserConnStr.LostFocus
		This.Value = chrtran(This.Value, chr(13) + chr(10), '')
		
	ENDPROC

	PROCEDURE opgConnection.InteractiveChange
		dodefault()
		
		This.Parent.RefreshControls()
		
		* For Chooce ODBC connection for first time
		IF This.Value = 2 AND This.Parent.opgODBCType.Value = 1 AND This.Parent.cmbDSN.ListIndex = 0
			This.Parent.GEtdsns()
		ENDIF
	ENDPROC

	PROCEDURE opgODBCType.InteractiveChange
		dodefault()
		DO CASE 
			CASE This.Value = 1 AND This.Parent.cmbDSN.ListCount = 0
				This.Parent.Getdsns()
			CASE This.Value =2 AND This.Parent.cmbServers.ListCount = 0
				This.Parent.Getallservers()
		ENDCASE
		This.Parent.REfreshcontrols()
	ENDPROC

	PROCEDURE opgODBCType.ProgrammaticChange
		This.InteractiveChange()
	ENDPROC

	PROCEDURE txtDSNPassword.LostFocus
		This.Value = chrtran(This.Value, chr(13) + chr(10), '')
		
	ENDPROC

	PROCEDURE txtDSNUserName.LostFocus
		This.Value = chrtran(This.Value, chr(13) + chr(10), '')
		
	ENDPROC

	PROCEDURE txtServerPWD.LostFocus
		This.Value = chrtran(This.Value, chr(13) + chr(10), '')
		
	ENDPROC

	PROCEDURE txtServerUID.LostFocus
		This.Value = chrtran(This.Value, chr(13) + chr(10), '')
		
	ENDPROC

ENDDEFINE

DEFINE CLASS cfieldtypemap AS basecontainer OF "basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdTypeMap" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcFldName.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcType.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtType.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtType.cboDataTypes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtLength.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtLength.txtLength" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtPrec.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtPrec.txtPrecision" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtNull.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTypeMap.grcRmtNull.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdReset" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\upsizing.h"
	*<DefinedPropArrayMethod>
		*m: crecordsource_assign
		*p: crecordsource
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	crecordsource = 
	Height = 270
	Name = "cfieldtypemap"
	Width = 423

	ADD OBJECT 'cmdReset' AS basecommandbutton WITH ;
		Caption = "\<Default", ;
		Left = 330, ;
		Name = "cmdReset", ;
		TabIndex = 6, ;
		Top = 24, ;
		Width = 73
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'grdTypeMap' AS basegrid WITH ;
		AllowHeaderSizing = .F., ;
		AllowRowSizing = .F., ;
		ColumnCount = 6, ;
		DeleteMark = .F., ;
		Height = 212, ;
		HighlightStyle = 2, ;
		Name = "grdTypeMap", ;
		RecordMark = .F., ;
		ScrollBars = 2, ;
		SplitBar = .F., ;
		TabIndex = 5, ;
		Top = 50, ;
		Width = 419, ;
		Column1.FontName = "Tahoma", ;
		Column1.FontSize = 8, ;
		Column1.Name = "grcFldName", ;
		Column1.ReadOnly = .T., ;
		Column1.Width = 122, ;
		Column2.FontName = "Tahoma", ;
		Column2.FontSize = 8, ;
		Column2.Name = "grcType", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 74, ;
		Column3.FontName = "Tahoma", ;
		Column3.FontSize = 8, ;
		Column3.Name = "grcRmtType", ;
		Column3.Width = 78, ;
		Column4.Alignment = 1, ;
		Column4.FontName = "Tahoma", ;
		Column4.FontSize = 8, ;
		Column4.Name = "grcRmtLength", ;
		Column4.Width = 47, ;
		Column5.FontName = "Tahoma", ;
		Column5.FontSize = 8, ;
		Column5.Name = "grcRmtPrec", ;
		Column5.Width = 47, ;
		Column6.Alignment = 2, ;
		Column6.FontName = "Tahoma", ;
		Column6.Name = "grcRmtNull", ;
		Column6.Sparse = .F., ;
		Column6.Width = 23
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="grid" />

	ADD OBJECT 'grdTypeMap.grcFldName.Header1' AS header WITH ;
		Caption = " Field name", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTypeMap.grcRmtLength.Header1' AS header WITH ;
		Alignment = 1, ;
		Caption = "Width ", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTypeMap.grcRmtLength.txtLength' AS basetextbox WITH ;
		Alignment = 1, ;
		Name = "txtLength", ;
		TabIndex = 1
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdTypeMap.grcRmtNull.Check1' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "", ;
		Centered = .T., ;
		Height = 17, ;
		Left = 7, ;
		Name = "Check1", ;
		Top = 21, ;
		Width = 60
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'grdTypeMap.grcRmtNull.Header1' AS header WITH ;
		Caption = " Null", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTypeMap.grcRmtPrec.Header1' AS header WITH ;
		Caption = " Precision", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTypeMap.grcRmtPrec.txtPrecision' AS basetextbox WITH ;
		Name = "txtPrecision", ;
		TabIndex = 1, ;
		Visible = .T.
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdTypeMap.grcRmtType.cboDataTypes' AS basecombobox WITH ;
		BorderStyle = 0, ;
		Margin = 2, ;
		Name = "cboDataTypes", ;
		RowSourceType = 5, ;
		SpecialEffect = 1, ;
		TabIndex = 1
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'grdTypeMap.grcRmtType.Header1' AS header WITH ;
		Caption = " Server type", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTypeMap.grcType.Header1' AS header WITH ;
		Caption = " FoxPro type", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />
	
	PROCEDURE crecordsource_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		
		LOCAL lcEnumTablesTbl, lcAlias, lcEnumfields, lnOldArea, ;
			lcBigString,i, lnWidth
		
		LOCAL lcFilterExpr as String
		
		THIS.cRecordsource = m.vNewVal
		IF EMPTY(THIS.cRecordsource)
			This.grdTypeMap.RecordSource = ""
			RETURN 
		ENDIF
		
		PRIVATE aTempArray, aTimeStamp[2]
		lnOldArea=SELECT()
		lcEnumTablesTbl = RTRIM(Thisform.oEngine.EnumTablesTbl)
		
		lcAlias = vNewVal
		
		EXTERNAL ARRAY ATABLESTOEXPORT
		
		*Refresh the table combo box if appropriate
		IF Thisform.oEngine.TableCboRecalc THEN
			*set datasource of combobox
			SELECT TblName FROM &lcEnumTablesTbl WHERE Export=.T. AND Type = "T";
				INTO ARRAY aTablesToExport
		ENDIF
		
		
		WITH This
			*Refresh the table combo box if appropriate
			IF Thisform.oEngine.AnalyzeFieldsRecalc=.T. THEN
				Thisform.oEngine.AnalyzeFields
				IF Thisform.oEngine.GridFilled=.T. THEN
					.grdTypeMap.refresh()
				ENDIF
			ENDIF
		
			*The interactive change event of the data type combo
			*relies on having RI and index information
			IF Thisform.oEngine.GetRiInfoRecalc THEN
				Thisform.oEngine.GetRIInfo()
				*(This routine calls the index analysis proc)
			ENDIF
		
			If !Thisform.oEngine.GridFilled THEN
				*Set number of columns and sizes based on server type
				lnWidth = .grdTypeMap.Width - sysmetric(5) - sysmetric(3) * 2
				IF Thisform.oEngine.ServerType="Oracle" OR RTRIM(Thisform.oEngine.ServerType)=="SQL Server95" THEN
					.grdTypeMap.grcType.width      = lnWidth * 0.19
					.grdTypeMap.grcRmtType.width   = lnWidth * 0.20
					.grdTypeMap.grcRmtLength.width = lnWidth * 0.12
					.grdTypeMap.grcRmtPrec.width   = lnWidth * 0.12
					.grdTypeMap.grcFldName.width   = lnWidth - .grdTypeMap.grcType.width - ;
						.grdTypeMap.grcRmtType.width - .grdTypeMap.grcRmtLength.width - ;
						.grdTypeMap.grcRmtPrec.width - .grdTypeMap.grcRmtNull.Width - 2
					.grdTypeMap.grcRmtPrec.visible=.T.
					.grdTypeMap.grcRmtPrec.enabled=.T.
				ELSE
					.grdTypeMap.grcType.width      = lnWidth * 0.23
					.grdTypeMap.grcRmtType.width   = lnWidth * 0.24
					.grdTypeMap.grcRmtLength.width = lnWidth * 0.16
					.grdTypeMap.grcFldName.width   = lnWidth - .grdTypeMap.grcType.width - ;
						.grdTypeMap.grcRmtType.width - .grdTypeMap.grcRmtLength.width - ;
						.grdTypeMap.grcRmtNull.Width - 2
					.grdTypeMap.grcRmtPrec.width=0
					.grdTypeMap.grcRmtPrec.visible=.F.
					.grdTypeMap.grcRmtPrec.enabled=.F.
				ENDIF
		
				IF Thisform.oEngine.MappingTable=="" THEN
					lcAlias=Thisform.oEngine.UniqueCursorName("UserType")
					lcEnumfields=RTRIM(Thisform.oEngine.EnumFieldsTbl)
					USE &lcEnumFields AGAIN IN 0 ALIAS &lcAlias
					SELECT (lnOldArea)
					Thisform.oEngine.MappingTable=lcAlias
				ELSE
					lcAlias=RTRIM(Thisform.oEngine.MappingTable)
				ENDIF
				
				IF Thisform.oEngine.TableCboRecalc
					SELECT (Thisform.oEngine.MappingTable)
					Thisform.oEngine.FiltCond=aTablesToExport[1]
					SET FILTER TO RTRIM(TblName)==RTRIM(Thisform.oEngine.FiltCond)
					SELECT (lnOldArea)
					Thisform.oEngine.TableCboRecalc=.F.
				ENDIF
				
				.grdTypeMap.RecordSource=lcAlias
				.grdTypeMap.grcFldName.ControlSource=lcalias + ".Fldname"
				.grdTypeMap.grcType.ControlSource=lcAlias + ".Combotype"
				.grdTypeMap.grcRmtType.ControlSource=lcalias + ".RmtType"
				.grdTypeMap.grcRmtLength.ControlSource=lcalias + ".RmtLength"
				.grdTypeMap.grcRmtLength.CurrentControl="txtLength"
				.grdTypeMap.grcRmtNull.ControlSource = lcAlias  + ".RmtNull"
				IF Thisform.oEngine.ServerType="Oracle" OR Thisform.oEngine.ServerType=="SQL Server95" THEN
					.grdTypeMap.grcRmtPrec.ControlSource=lcalias + ".RmtPrec"
					.grdTypeMap.grcRmtPrec.CurrentControl="txtPrecision"
				ENDIF
				
				
				Thisform.oEngine.GridFilled=.T.
				llCboRecalc=.T.
		
				*Generate an array for each FoxPro datatype
				Thisform.oEngine.CreateTypeArrays
				.grdTypeMap.grcRmtType.CurrentControl="cboDataTypes"
				.grdTypeMap.grcRmtType.cboDataTypes.GotFocus
				
			ENDIF
		
		
			*Make sure read/write status of length and precision fields is right
			SELECT(.grdTypeMap.RecordSource)
			lcFilterExpr = "Upper(ALLTRIM(" + .grdTypeMap.RecordSource + ".TblName)) == UPPER(ALLTRIM(" + lcEnumTablesTbl + ".TblName))"
			if eof(lcEnumTablesTbl)
				go top in (lcEnumTablesTbl)
			endif eof(lcEnumTablesTbl)
			SET FILTER TO &lcFilterExpr
			LOCATE
			
			.grdTypeMap.Refresh()
			.grdTypeMap.AfterRowColChange()
		ENDWITH
		
		Select(lnOldArea)
		
	ENDPROC

	PROCEDURE cmdReset.Click
		LOCAL lcTableName as String
		
		lcTableName=RTRIM(EVALUATE(ALLTRIM(Thisform.oEngine.EnumTablesTbl) + ".TblName"))
		
		Thisform.oEngine.DefaultMapping(lcTableName)
		
		this.parent.grdTypeMap.refresh()
		
	ENDPROC

	PROCEDURE grdTypeMap.AfterRowColChange
		PARAMETERS nColIndex
		*If the user changes rows, the readonly property of the
		*length and possibly precision columns may need to be changed
		
		IF Thisform.oEngine.OldRow<>this.Activerow THEN
			LOCAL lcMappingTable, lcRmtType, lcLocalType, lnOldArea
			
			lcMappingTable=Thisform.oEngine.MappingTable
			lcRmtType=RTRIM(&lcMappingTable..RmtType)
			lcLocalType=RTRIM(&lcMappingTable..DataType)
			lnOldArea=SELECT()
			SELECT _TypeMap	
			LOCATE FOR RTRIM(RemoteType)==lcRmtType ;
				AND RTRIM(LocalType)==lcLocalType ;
				AND Server=RTRIM(Thisform.oEngine.ServerType)
			this.grcRmtLength.Enabled=_TypeMap.VarLength
			this.grcRmtPrec.Enabled=_TypeMap.HasPrec
		
			this.grcRmtLength.Readonly=!_TypeMap.VarLength
			this.grcRmtPrec.Readonly=!_TypeMap.HasPrec
			SELECT(lnOldArea)
		ENDIF
		
		Thisform.oEngine.OldRow=this.ActiveRow
		
	ENDPROC

	PROCEDURE grdTypeMap.grcRmtLength.txtLength.Valid
		LOCAL lnOldArea, lcRmtType
		
		IF this.value<0 THEN
			RETURN .F.
		ENDIF
		
		
		lnOldArea=SELECT()
		SELECT (Thisform.oEngine.MappingTable)
		lcRmtType=RmtType
		SELECT(lnOldArea)
		
		*make sure value entered isn't too big
		IF Thisform.oEngine.ServerType="Oracle" THEN
			
			#IF SUPPORT_ORACLE
				DO CASE
					CASE lcRmtType=="varchar2"
						IF this.value > 2000 OR this.value <= 0 THEN
							RETURN .F.
						ENDIF
		
					CASE lcRmtType=="char"
						IF this.value>255 OR this.value<=0 THEN
							RETURN .F.
						ENDIF
						
					CASE lcRmtType=="number"
						IF this.value>38 OR this.value<=0 THEN
							RETURN .F.
						ENDIF
					
					CASE lcRmtType=="raw"
						IF this.value > 255 OR this.value <= 0 THEN
							RETURN .F.
						ENDIF
						
				ENDCASE
			#ENDIF
				
		ELSE
			DO CASE
			
				CASE lcRmtType=="numeric" OR lcRmtType=="decimal"
					IF this.value>38 OR this.value<=0 THEN
						RETURN .F.
					ENDIF
					
				OTHERWISE
					*char, varchar, binary, and varbinary all have a limit of 255
					IF this.value>255 ;
						OR this.value<0 ;
						OR (this.value=0 AND this.enabled) THEN
						RETURN .F.
					ENDIF
					
			ENDCASE
			
		ENDIF
		
	ENDPROC

	PROCEDURE grdTypeMap.grcRmtPrec.txtPrecision.Valid
		IF Thisform.oEngine.ServerType="Oracle" THEN
			#IF SUPPORT_ORACLE
				if this.value > 127 or this.value < -84 then
					return .f.
				endif
			#ENDIF
		ELSE
			if this.value > 38 or this.value < 0 then
				return .f.
			endif
		ENDIF
	ENDPROC

	PROCEDURE grdTypeMap.grcRmtType.cboDataTypes.GotFocus
		LOCAL lcMappingTable
		lcMappingTable=Thisform.oEngine.MappingTable
		this.rowsource="Thisform.oEngine." + rtrim(&lcMappingTable..DataType)
		Thisform.oEngine.OldType=this.value
		
	ENDPROC

	PROCEDURE grdTypeMap.grcRmtType.cboDataTypes.InteractiveChange
		*When user changes data type, need to supply default
		*length and (sometimes) precision
		
		LOCAL lcMappingTable, lnLength, lnPrecision, lnOldArea, ;
			llCantIndex, lcRmtType, lnUserChoice, llInIndex, llUndo, ;
			aIndexNames, aRelatedTables, lcTableName, ;
			lcFieldName, lcRmtFieldname, llTwoLongs, lcOtherLong
		
		lcMappingTable=Thisform.oEngine.MappingTable
		lnOldArea=SELECT()
		SELECT &lcMappingTable
		lcRmtType=RTRIM(this.value)
		
		IF Thisform.oEngine.ServerType="Oracle" THEN
			#IF SUPPORT_ORACLE
				DO CASE
					CASE lcRmtType=="varchar2"
						IF &lcMappingTable..DataType="M" THEN
							lnLength=2000
						ELSE
							lnLength=&lcMappingTable..Length
						ENDIF
						lnPrecision=0
		
					CASE lcRmtType=="char"
						IF &lcMappingTable..DataType="M" THEN
							lnLength=255
						ELSE
							lnLength=&lcMappingTable..Length
						ENDIF
						lnPrecision=0
						
					CASE lcRmtType=="number"
						*If local type is money, stick in different default values
						*otherwise use the length and precision of the local type
						IF &lcMappingTable..DataType="Y" THEN
							lnLength=19
							lnPrecision=4
						ELSE
							IF &lcMappingTable..DataType = "I" THEN
								lnLength = 11
								lnPrecision = 0
							ELSE
								lnLength=&lcMappingTable..Length
								lnPrecision=&lcMappingTable..Precision
							ENDIF
						ENDIF
					
					CASE lcRmtType=="raw"
						lnLength=255
						lnPrecision=0
						llCantIndex=.T.
						
					OTHERWISE
						*Case of long, date, and long raw
						lnLength=0
						lnPrecision=0
						IF lcRmtType=="LONG RAW" THEN
							llCantIndex=.T.
						ENDIF
					
				ENDCASE
			#ENDIF
			
		ELSE
		
			DO CASE
				*
				*SQL 4.x datatypes
				*
				CASE lcRmtType=="varchar" OR ;
					lcRmtType=="char"
					IF &lcMappingTable..DataType="M" ;
						OR &lcMappingTable..DataType="G" THEN
						lnLength=255
					ELSE
						lnLength=&lcMappingTable..Length
					ENDIF
					lnPrecision=0
		
					
				CASE lcRmtType=="binary" OR ;
					lcRmtType=="varbinary"
						lnLength=255
						lnPrecision=0
				*
				*SQL '95 datatype
				*
				CASE lcRmtType=="numeric" OR ;
					lcRmtType=="decimal"
						lnLength=&lcMappingTable..Length
						lnPrecision=&lcMappingTable..Precision
					
				OTHERWISE
					lnLength=0
					IF lcRmtType=="bit" OR lcRmtType=="text" OR lcRmtType="image" THEN
						llCantIndex=.T.
					ENDIF
					lnLength=0
					lnPrecision=0
				
					
			ENDCASE
		
		ENDIF
		
		lcTableName=RTRIM(TblName)
		lcFieldName=RTRIM(FldName)
		lcRmtFieldname=RTRIM(RmtFldName)
		
		*See if field is in any indexes
		IF llCantIndex THEN
			DIMENSION aIndexNames[1]
			llInIndex=Thisform.oEngine.InIndex(@aIndexNames,lcFieldName,lcTableName)
		ENDIF
				
		*See if field is a primary or foreign key
		llInKey=Thisform.oEngine.InKey(lcRmtFieldname, lcTableName)
		
		#IF SUPPORT_ORACLE
			*See if there is already a field using the long data type
			IF RTRIM(lcRmtType)=="long" OR RTRIM(lcRmtType)=="long raw" THEN
				llTwoLongs=Thisform.oEngine.TwoLongs(lcTableName, lcFieldName, @lcOtherLong)
			ENDIF
		#ENDIF
				
		DO CASE
		
			#IF SUPPORT_ORACLE
				*Don't allow two fields of type Long or Long Raw
				CASE llTwoLongs
					lcMsg=STRTRAN(TWO_LONGS_WRONG_LOC,'|1',RTRIM(lcOtherLong))
					=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
					llUndo=.T.
			#ENDIF
		
			*If the field is a key field and now unindexable, don't allow the change
			CASE llInKey AND llCantIndex
				lcMsg=STRTRAN(NO_NO_LOC,"|1",RTRIM(&lcMappingTable..FldName))
				lcMsg=STRTRAN(lcMsg,"|2",RTRIM(this.value))
				=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
				llUndo=.T.
		
			*If the field is in a key but indexable, warn user to change other fields too
			CASE llInKey AND !llCantIndex
				lcMsg=STRTRAN(CASCADE_TYPE_CHANGE_LOC,"|1",RTRIM(FldName))
				=MESSAGEBOX(lcMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
		
			*If the field is not a key field but is an index, warn user
			CASE (llCantIndex AND llInIndex) AND !llInKey
				lcMsg=STRTRAN(IN_INDEX_LOC,"|1",RTRIM(FldName))
				lcMsg=STRTRAN(lcMsg,"|2",RTRIM(this.value))
				lnUserChoice=MESSAGEBOX(lcMsg,ICON_EXCLAMATION+YES_NO_BUTTONS,TITLE_TEXT_LOC)
				IF lnUserChoice=DONT_INDEX THEN
					*Mark indexes as not to be created
					Thisform.oEngine.DontIndex(lcFieldName,lcTableName)
				ELSE
					llUndo=.T.
				ENDIF
				
		ENDCASE
		
		IF llUndo THEN
			this.value=Thisform.oEngine.OldType
		ELSE
			REPLACE &lcMappingTable..RmtLength with lnLength, ;
				&lcMappingTable..RmtPrec with lnPrecision
			Thisform.oEngine.OldType=this.value
		
			*Now set readonly property of length and precision columns of the grid
			*Force recalc
			Thisform.oEngine.OldRow=this.parent.parent.ActiveRow + 1
			this.parent.parent.AfterRowColChange
		ENDIF
		
		SELECT(lnOldArea)
		
	ENDPROC

	PROCEDURE grdTypeMap.Init
		* the grid picks up the current alias as rowsource
		* if it is an upsizable table open SHARED, it gets closed and reopened EXCLUSIVE and
		* this disables the column objects in the grid control
		this.recordsource = ""
	ENDPROC

ENDDEFINE

DEFINE CLASS choosesourcedb AS basewizardcontainer OF "basewizard.vcx" 		&& Choose database to upsize
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\" ClassIcon="c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Wizlabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lstList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOpen" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: createdbarray
		*m: exclusonly
		*m: reallychangesourcedb
		*m: selffill
		*p: oldlistvalue
		*p: reallylostfocus
		*p: selffilled
		*a: aopendatabases[1,1]
	*</DefinedPropArrayMethod>

	BackColor = 192,192,192
	BackStyle = 0
	BorderWidth = 0
	Height = 134
	Name = "choosesourcedb"
	TabIndex = 1
	Width = 264

	ADD OBJECT 'cmdOpen' AS basewizardcommandbutton WITH ;
		Caption = "\<Open...", ;
		Left = 156, ;
		Name = "cmdOpen", ;
		Top = 15
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'lstList' AS basewizardlistbox WITH ;
		BoundColumn = 2, ;
		ControlSource = "Thisform.cSourceDatabase", ;
		Height = 115, ;
		IntegralHeight = .F., ;
		Name = "lstList", ;
		RowSourceType = 5, ;
		Top = 15, ;
		Width = 133
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="listbox" />

	ADD OBJECT 'Wizlabel1' AS basewizardlabel WITH ;
		Caption = "\<Database to upsize:", ;
		Name = "Wizlabel1", ;
		TabIndex = 1, ;
		Top = 0
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />
	
	PROCEDURE createdbarray
		LOCAL i, aTempArray, lnGoodDBs, lnOpenDBs, lnOldArea, llNotExclusible
		dimension This.aOpenDatabases[1,2]
		dimension aTempArray[1,2]
		
		This.aOpenDatabases = .F.
		llNotExclusible = .F.
		*Throw out any databases that are not or can't be opened exclusively
		lnOpenDBs = adatabase(aTempArray)
		lnGoodDBs = 0
		lnOldArea = SELECT()
		IF lnOpenDBs <> 0 
			FOR i = 1 to ALEN(aTempArray,1)
				SELECT 0
				if left(aTempArray[i,1], 6) <> 'UPSIZE'
					USE(aTempArray[i,2]) AGAIN
					IF ISEXCLUSIVE() THEN
						lnGoodDBs = lnGoodDBs+1
						IF lnGoodDBs > 1 THEN
							DIMENSION This.aOpenDatabases[ALEN(This.aOpenDatabases,1)+1,2]
						ENDIF
						This.aOpenDatabases[lnGoodDBs,1]=LOWER(aTempArray[i,1])
						This.aOpenDatabases[lnGoodDBs,2]=aTempArray[i,2]
					ELSE
						SET DATABASE TO aTempArray(i,1)
						CLOSE DATABASES
						OPEN DATABASE aTempArray(i,2) EXCLUSIVE
						lnGoodDBs=lnGoodDBs+1
						IF lnGoodDBs > 1 THEN
							DIMENSION This.aOpenDatabases[ALEN(This.aOpenDatabases,1)+1,2]
						ENDIF
						This.aOpenDatabases[lnGoodDBs,1]=LOWER(aTempArray[i,1])
						This.aOpenDatabases[lnGoodDBs,2]=aTempArray[i,2]
					ENDIF
					USE	
				endif left(aTempArray[i,1], 6) <> 'UPSIZE'
			NEXT i
		ENDIF
		
		IF lnGoodDBs=0 THEN
			This.aOpenDatabases[1,1]="<No database open>"
			this.lstList.enabled = .F.
		ELSE
			this.lstList.enabled = .T.
		ENDIF
		SELECT (lnOldArea)
		IF llNotExclusible
			=MESSAGEBOX("Databases which are not opened exclusively will not be available for upsizing.", 48,ThisForm.Caption)
		ENDIF
	ENDPROC

	PROCEDURE exclusonly
		
		
	ENDPROC

	PROCEDURE Init
		* Fill the listbox with available databases.
		
		This.SelfFill()
		
		* Bind to the SetSourceDatabase method of the form.
		
		bindevent(Thisform, 'SetSourceDatabase', This, 'SelfFill', 1)
		
	ENDPROC

	PROCEDURE reallychangesourcedb
		LOCAL lnElement, lnSelectedDB, i, llReallyChange
		
		* Changing the source database impacts:
		*	a) tables selected
		*	b) connection definition (if used)
		
		* If neither a connection definition has been chosen, nor the connections enumerated,
		* nor a table chosen, nor tables analyzed, bail
		
		IF Thisform.oEngine.UserConnection = "" ;
			AND !Thisform.lTableChosen AND Thisform.oEngine.AnalyzeTablesRecalc ;
			OR EMPTY(Thisform.oEngine.SourceDB) THEN
			RETURN .T.
		ENDIF
		
		* Also, if the database name hasn't changed, we can bail
		lnSelectedDB = Thisform.cSourceDatabase
		IF lnSelectedDB = Thisform.oEngine.SourceDB
			RETURN .T.
		ENDIF
		
		* Prevent lostfocus event of txtText from firing
		this.ReallyLostFocus =.F.
		* If connection def chosen or a table has been chosen, warn the user, change if they want to
		IF Thisform.lTableChosen OR !Thisform.oEngine.UserConnection = "" THEN
			lnUserInput = MESSAGEBOX("You have changed the database you are upsizing.  If you continue, the tables you chose to " + ;
									"upsize will be reset." + CHR(10) + CHR(13) + CHR(10) + CHR(13)+ ;
									"Continue?",4 + 48,ThisForm.Caption)
		ELSE
			lnUserInput = 6
		ENDIF	
		this.ReallyLostFocus = .T.
		
		IF lnUserInput = 6 THEN
			Thisform.AnalysisCleanup()
			RETURN .T.
		ELSE
			this.lstList.value = RTRIM(this.OldListValue)
			this.cmdOpen.setfocus
			RETURN .F.
		ENDIF
	ENDPROC

	PROCEDURE selffill
		lparameters tcDatabase	&& only here because BINDEVENT requires it
		LOCAL lcDBName
		
		this.CreateDBArray
		ASORT(This.aOpenDatabases)
		this.lstList.rowsource = "This.Parent.aOpenDatabases"
		IF This.aOpenDatabases[1] <> "<No database open>"
			lcDBName = LOWER(Thisform.oEngine.JustStem(DBC()))
			IF EMPTY(lcDBName)
				lcDBName = This.aOpenDatabases[1,1]
			ENDIF
			this.lstList.DisplayValue = lcDbName
			this.OldListValue = This.lstList.Value
		ENDIF
		
		this.SelfFilled = .T.
		this.ReallyLostFocus = .T.
	ENDPROC

	PROCEDURE cmdOpen.Click
		LOCAL lcNameOnly, lcOld, lcMsg, lcOtherDatabase
		LOCAL loException as Exception
		LOCAL lnErrorNO as Integer
		
		lcOtherDatabase = GETFILE("dbc", 'File Name:', 'OK')
		
		IF EMPTY(lcOtherDatabase)
			RETURN
		ENDIF
		
		IF !FILE(lcOtherDatabase)
			* should not occur
			=MESSAGEBOX("File not Found")
			RETURN
		ENDIF
		
		lnErrorNO = 0
		
		TRY
			OPEN DATABASE (lcOtherDatabase) EXCLUSIVE
		CATCH TO loException
			lnErrorNO = loException.ErrorNo
		ENDTRY
		
		IF lnErrorNO > 0 THEN
			IF lnErrorNO = 1705
				lcMsg = "Cannot open exclusive " + lcOtherDatabase
			ELSE
				lcMsg = "Cannot open "  + lcOtherDatabase
			ENDIF
			=MESSAGEBOX(lcMsg,48, ThisForm.Caption)
			RETURN
		ENDIF
		
		* select current database
		WITH This.parent
			.CreateDBArray()
			.lstList.Requery()
			.lstList.value = lcOtherDatabase
			.OldListValue = .lstList.Value
		ENDWITH
		
	ENDPROC

	PROCEDURE lstList.DblClick
		IF TYPE("ThisForm.cmdNext") = "O"
			ThisForm.cmdNext.Click()
		ENDIF
	ENDPROC

ENDDEFINE

DEFINE CLASS choosetargetdb AS basewizardcontainer OF "basewizard.vcx" 		&& Combo box of databases on selected server or text box for new name
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" ProjectClassIcon="c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\" ClassIcon="c:\program files\microsoft visual foxpro 9\tools\xsource\vfpsource\apps\fox30\" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cboDatabases" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="opgNewOrExisting" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDescription" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblDBExists" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtNewDatabaseName" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\alldefs.h"
	*<DefinedPropArrayMethod>
		*m: checkdbpermissions
		*m: connecttotarget
		*m: isvalid
		*m: moveforward
		*m: selffill
		*m: setcomp
		*p: oldlen
		*p: selffilled
		*a: aserverdatabases[1,1]
	*</DefinedPropArrayMethod>

	Height = 87
	Name = "choosetargetdb"
	oldlen = 0
	TabIndex = 1
	Width = 280
	_memberdata = <VFPData>
		<memberdata name="aserverdatabases" type="property" display="aServerDatabases"/>
		<memberdata name="checkdbpermissions" type="method" display="CheckDbPermissions"/>
		<memberdata name="connecttotarget" type="method" display="ConnectToTarget"/>
		<memberdata name="enabled_assign" type="method" display="Enabled_Assign"/>
		<memberdata name="isvalid" type="method" display="IsValid"/>
		<memberdata name="moveforward" type="method" display="MoveForward"/>
		<memberdata name="oldlen" type="property" display="OldLen"/>
		<memberdata name="selffill" type="method" display="SelfFill"/>
		<memberdata name="selffilled" type="property" display="SelfFilled"/>
		<memberdata name="setcomp" type="method" display="SetComp"/>
		</VFPData>

	ADD OBJECT 'cboDatabases' AS basewizardcombobox WITH ;
		ControlSource = "Thisform.cTargetDatabase", ;
		Enabled = .F., ;
		Name = "cboDatabases", ;
		RowSourceType = 5, ;
		TabIndex = 3, ;
		Top = 26, ;
		Visible = .F., ;
		Width = 133
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="combobox" />

	ADD OBJECT 'lblDBExists' AS basewizardlabel WITH ;
		Caption = "<db name already exists message goes here>", ;
		FontBold = .T., ;
		ForeColor = 255,0,0, ;
		Height = 15, ;
		Name = "lblDBExists", ;
		TabIndex = 5, ;
		Top = 59, ;
		Visible = .F., ;
		Width = 263, ;
		WordWrap = .T.
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblDescription' AS basewizardlabel WITH ;
		Caption = "lblDescription", ;
		Left = 1, ;
		Name = "lblDescription", ;
		TabIndex = 1
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'opgNewOrExisting' AS basewizardoptiongroup WITH ;
		ButtonCount = 2, ;
		ControlSource = "Thisform.nDatabaseType", ;
		Height = 43, ;
		Left = 145, ;
		Name = "opgNewOrExisting", ;
		TabIndex = 4, ;
		Top = 19, ;
		Width = 68, ;
		baseoptionbutton1.Caption = "E\<xisting", ;
		baseoptionbutton1.Left = 5, ;
		baseoptionbutton1.Name = "baseoptionbutton1", ;
		baseoptionbutton1.Top = 5, ;
		baseoptionbutton2.Caption = "Ne\<w", ;
		baseoptionbutton2.Left = 5, ;
		baseoptionbutton2.Name = "baseoptionbutton2", ;
		baseoptionbutton2.Top = 23, ;
		baseoptionbutton2.Value = 0
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'txtNewDatabaseName' AS basewizardtextbox WITH ;
		ControlSource = "Thisform.cNewTargetDatabase", ;
		Name = "txtNewDatabaseName", ;
		TabIndex = 2, ;
		Top = 26, ;
		Width = 133
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="textbox" />
	
	PROCEDURE checkdbpermissions
		*Here checking to see the user can create tables, defaults, and sprocs
		
		LOCAL lcErrMsg, lcSQL, lnOldArea, lnRetVal, lnRetVal, ;
			lcServerDB, aPerm, lcCRLF, llRetVal
			
		lcServerDB=RTRIM(this.cboDatabases.value)
		Thisform.oEngine.ServerDBName=lcServerDB
		lcCRLF=CHR(10)+CHR(13)
		
		*Set permissions to true, then flip them false as appropriate
		Thisform.oEngine.Perm_Table		=	.T.
		Thisform.oEngine.Perm_Default	=	.T.
		Thisform.oEngine.Perm_Sproc		=	.T.
		Thisform.oEngine.Perm_Index		=	.T.
		Thisform.oEngine.Perm_Trigger	=	.T.
		
		* Need special handling for SQL 7.0 and higher
		IF Thisform.oEngine.ServerVer >= 7 
			IF !THIS.SetComp(lcServerDB)
				RETURN .F.
			ENDIF
		ENDIF
		
		*If the user is 'sa', bail
		IF Thisform.oEngine.UserID=1 THEN
			RETURN .T.
		ENDIF
		
		*Use the target database
		IF !this.ConnectToTarget() THEN
			*If the user can't even use the database, they clearly don't have much
			*in the way of permissions
			lcErrMsg=STRTRAN(CANT_CONNECT_LOC,'|1',lcServerDb)
			=MESSAGEBOX(lcErrMsg,48,TITLE_TEXT_LOC)
			RETURN .F.
		ENDIF
		
		*Get user name and id (overwrite the user name and id that came from the Master database)
		lcUserName=""
		lnUserID=0
		lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_NAME()",@lcUserName,"Exp")
		Thisform.oEngine.UserName=lcUserName
		lnRetVal=Thisform.oEngine.SingleValueSPT("select USER_ID()",@lnUserID,"Exp")
		Thisform.oEngine.UserID=lnUserID
		
		*Try to create a table
		lcSQL="Create table __fo_1o (x char(1))"
		llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
		IF llRetVal THEN
			*drop the table, ignore errors
			lcSQL="Drop table __fo_1o"
			=Thisform.oEngine.ExecuteTempSPT(lcSQL)
		ELSE
			Thisform.oEngine.Perm_table=.F.
		ENDIF
		
		*Try to create a default
		lcSQL="Create default __w_hip_6 as 'x'"
		llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
		IF llRetVal THEN
			*drop the default
			lcSQL="Drop default __w_hip_6"
			=Thisform.oEngine.ExecuteTempSPT(lcSQL)
		ELSE
			Thisform.oEngine.Perm_Default=.F.
		ENDIF
		
		*Try to create a sproc
		lcSQL="Create procedure __R_W_F_ as SELECT USER_NAME()"
		llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
		IF llRetVal THEN
			*drop the sproc
			lcSQL="Drop procedure __R_W_F_"
			=Thisform.oEngine.ExecuteTempSPT(lcSQL)
		ELSE
			Thisform.oEngine.Perm_Sproc=.F.
		ENDIF
		
		lcErrMsg=""
		IF !Thisform.oEngine.Perm_Table THEN
			lcErrMsg=CANT_CREATE_TABLE
		ENDIF
		
		IF !Thisform.oEngine.Perm_Default THEN
			IF !EMPTY(lcErrMsg) THEN
				IF Thisform.oEngine.Perm_Sproc THEN
					lcErrMsg=lcErrMsg+ OR_LOC
				ELSE
					lcErrMsg=lcErrMsg+ ", "
				ENDIF
			ENDIF
			lcErrMsg=lcErrMsg+CANT_CREATE_DEFAS
		ENDIF
		
		IF !Thisform.oEngine.Perm_Sproc THEN
			IF !EMPTY(lcErrMsg) THEN
				IF !Thisform.oEngine.Perm_Default and !Thisform.oEngine.Perm_Table THEN
					lcErrMsg=lcErrMsg+ ", " + OR_LOC
				ELSE
					lcErrMsg=lcErrMsg+ OR_LOC
				ENDIF
			ENDIF
			lcErrMsg=lcErrMsg+CANT_CREATE_SPROCS
		ENDIF
		
		IF !EMPTY(lcErrMsg) THEN
			lcErrMsg=STRTRAN(LACKING_PERMS_LOC,"|1",lcServerDB)+lcErrMsg + "."
			=MESSAGEBOX(lcErrMsg,ICON_EXCLAMATION,TITLE_TEXT_LOC)
		ENDIF
		
	ENDPROC

	PROCEDURE connecttotarget
		*If the user specified a database other than "Master"
		*when logging in, connect to it now
		
		LOCAL lcServerDB, lnRetVal, lnErrNo, lcErrMsg
		
		#DEFINE SQS_ERR_INVALUSER  		916			&&Executing incorrect SQL syntax; should only occur when creating user sprocs and defaults
		
		IF RTRIM(LOWER(Thisform.oEngine.ServerDBName))<>"master" THEN
			
			lcServerDB=RTRIM(Thisform.oEngine.ServerDBName)
			lnRetVal=Thisform.oEngine.ExecuteTempSPT("use " + lcServerDB, @lnErrNo, @lcErrMsg)
		
			IF lnErrNo=SQS_ERR_INVALUSER THEN
				RETURN .F.
			ENDIF
			
		ENDIF
		
	ENDPROC

	PROCEDURE isvalid
		local llReturn, ;
			lcDBName, ;
			lcExact, ;
			i
		This.lblDBExists.Visible = .F.
		llReturn = .T.
		lcDBName = alltrim(This.txtNewDatabaseName.Value)
		do case
			case This.opgNewOrExisting.Value = 1
		
			*If there's no name, bail.  The interactive change code insures the
			*user can't go anywhere until they enter a valid name
			case empty(lcDBName)
				llReturn = .F.
		
			*Make sure name isn't already taken
			otherwise
		*-- 2018-10-20 - JRL: added IF and ENDIF: if there are no database on the server, don't look for a duplicate
				if not empty(This.aServerDatabases)
					lcExact = set('EXACT')
					set exact on
					for i = 1 to alen(This.aServerDatabases, 1)
						if lower(This.aServerDatabases[i, 1]) = lower(lcDBName)
							This.lblDBExists.Caption = strtran(DUPLICATE_DBNAME_LOC, '|1', ;
								alltrim(This.txtNewDatabaseName.Value))
							This.lblDBExists.Visible = .T.
							llReturn = .F.
							exit
						endif lower(This.aServerDatabases[i, 1]) = lower(lcDBName)
					next i
					set exact &lcExact
		*-- 2018-10-20 - JRL
			    endif
		
			*see if entered name is acceptable to server
				if not Thisform.oEngine.ValidName(@lcDBName)
					This.txtNewDatabaseName.Value = lcDBName
					This.txtNewDatabaseName.SetFocus()
					llReturn = .F.
				endif not Thisform.oEngine.ValidName(@lcDBName)
		endcase
		Thisform.lTargetDatabaseValid = llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE moveforward
		*If user upsizing to existing database, check their permissions
		IF this.opgNewOrExisting.value<>NEW_DB THEN
			RETURN this.CheckDBPermissions()
		ENDIF
		
		
	ENDPROC

	PROCEDURE selffill
		local nRetVal, lcSQL, lnOldArea, lcExact,lnDatabaseCount
		
		wait window 'Getting databases...' nowait
		
		
		*Dis/enable based on user permission to create databases
		this.opgNewOrExisting.BaseOptionButton2.enabled=Thisform.oEngine.Perm_Database
		
		*Set option group to existing
		IF !Thisform.oEngine.Perm_Database THEN
			this.opgNewOrExisting.VALUE=EXISTING
			this.opgNewOrExisting.interactivechange()
			Thisform.oEngine.CreateNewDB=.F.
		***
		else
			this.opgNewOrExisting.Refresh()
		***
		ENDIF
				
		lnOldArea=SELECT()
		SELECT 0
		lcSQL="sp_helpdb"
		nRetVal=SQLEXEC(Thisform.oEngine.MasterConnHand,lcSQL)
		*user may not have permission to execute this sproc
		IF nRetVal=1 THEN
			lnDatabaseCount = RECCOUNT()
			DIMENSION This.aServerDatabases[lnDatabaseCount,2]
			COPY TO ARRAY This.aServerDatabases FIELDS Name
			USE
			FOR kk = 1 TO lnDatabaseCount
				This.aServerDatabases[kk,1] = ALLTRIM(This.aServerDatabases[kk,1])
			ENDFOR
			SELECT (lnOldArea)
		ELSE
			DIMENSION This.aServerDatabases[1,2]
			This.aServerDatabases[1,1]=Thisform.oEngine.ServerDBName
		ENDIF
		
		this.cboDatabases.rowsource="This.Parent.aServerDatabases"
		***this.cboDatabases.value=RTRIM(Thisform.oEngine.ServerDBName)
		do case
			case not empty(Thisform.cNewTargetDatabase)
				lcValue = Thisform.cNewTargetDatabase
			case not empty(Thisform.cTargetDatabase)
				lcValue = Thisform.cTargetDatabase
			otherwise
				lcValue = rtrim(Thisform.oEngine.ServerDBName)
		endcase
		This.cboDatabases.Value = lcValue
		***
		this.opgNewOrExisting.InteractiveChange()
		This.Refresh()
		this.SelfFilled=.T.
		
		wait clear
		
	ENDPROC

	PROCEDURE setcomp
		LPARAMETER tcDBName
		LOCAL lcSQL,lnCompLevel,llRetVal,lcDBName
		
		IF ATC("SQL Server",Thisform.oEngine.ServerType)=0
			RETURN
		ENDIF
		
		lcDBName=ALLTRIM(tcDBName)
		IF LOWER(lcDBName)="master"	&&don't allow changes to SQL7 master DB
			MESSAGEBOX(NO_SQL7UPSIZEMASTER_LOC)
			RETURN .F.
		endif
		*** DH 07/24/2013: RETURN .T. at this point since compatibility isn't used anymore.
		return .T.
		
		lnCompLevel=0
		lcSQL = "select cmptlevel from master.dbo.sysdatabases where name='"+lcDBName+"'"
		llRetVal=Thisform.oEngine.SingleValueSPT(lcSQL,@lnCompLevel,"cmptlevel")
		
		IF llRetVal AND lnCompLevel=>70
			Thisform.oEngine.nSQL7CompLevel = lnCompLevel
		
			* RMK - 2004/01/27 - added following to fix bug with not being able to set compatibility level when not logged in as SA
			lcSQL = [use ] + lcDBName
			llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
			
		    IF llRetVal
				lcSQL=[sp_dbcmptlevel ]+lcDBName+[,65]
				llRetVal=Thisform.oEngine.ExecuteTempSPT(lcSQL)
			ENDIF
			IF !llRetVal
				MESSAGEBOX(NO_SQL7BADCOMPLEVEL_LOC)
				RETURN .F.
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE lblDescription.Init
		This.Caption = NEW_LBL_DESC_LOC
		
	ENDPROC

	PROCEDURE opgNewOrExisting.InteractiveChange
		LOCAL llTxtNewDatabaseName, llCboDatabases
		
		IF this.value=EXISTING
			*If the user has already been to this step and chose new database *AND* gone
			*on to step 4 (thus creating a bunch of tables with device info), nuke that info
			IF Thisform.oEngine.DeviceRecalc=.F. THEN
				lnRetVal=MESSAGEBOX(REALLY_CHANGE_TARGET_LOC,YES_NO_BUTTONS+ICON_EXCLAMATION,TITLE_TEXT_LOC)
				IF lnRetVal = USER_YES THEN
					Thisform.oEngine.DeviceCleanUp
					Thisform.oEngine.ChooseTargetDBRecalc=.F.
					Thisform.oEngine.DataSourceChosen=.T.
					Thisform.oEngine.DeviceRecalc=.T.
				ELSE
					this.value=NEW_DB
					RETURN
				ENDIF
			ENDIF
			this.parent.txtNewDatabaseName.enabled=.F.
			this.parent.txtNewDatabaseName.visible=.F.
			this.parent.cboDatabases.enabled=(Thisform.oEngine.Userconnection=="")
			this.parent.cboDatabases.visible=.T.
			this.parent.lblDescription.caption=IIF(Thisform.oEngine.Userconnection=="", ;
				STRTRAN(EXISTING_LBL_DESC_LOC,"'|1'", ;
				iif(empty(Thisform.oEngine.DataSourceName), alltrim(Thisform.cServer), ;
				RTRIM(Thisform.oEngine.DataSourceName))), DATABASE_TXT_LOC + ":")
			Thisform.oEngine.CreateNewDB=.F.
		ELSE
			this.parent.cboDatabases.enabled=.F.
			this.parent.cboDatabases.visible=.F.
			this.parent.cboDatabases.ZOrder(1)
			this.parent.txtNewDatabaseName.enabled=.T.
			this.parent.txtNewDatabaseName.visible=.T.
			this.parent.txtNewDatabaseName.ZOrder(0)
			this.parent.txtNewDatabaseName.setfocus()
			IF ALLTRIM(this.parent.txtNewDatabaseName.value)==""
				this.parent.txtNewDatabaseName.value="" && SPACE(30)
			ENDIF
			this.parent.lblDescription.caption=NEW_LBL_DESC_LOC
			Thisform.oEngine.CreateNewDB=.T.
		endif
		This.Parent.IsValid()
		dodefault()
		
	ENDPROC

	PROCEDURE txtNewDatabaseName.InteractiveChange
		IF !CHRSAW() THEN
			this.parent.OldLen=LEN(ALLTRIM(this.value))
		endif
		This.Parent.IsValid()
		dodefault()
		
	ENDPROC

	PROCEDURE txtNewDatabaseName.LostFocus
		This.Value = chrtran(This.Value, chr(13) + chr(10), '')
		
	ENDPROC

ENDDEFINE

DEFINE CLASS ctablelist AS basewizardcontainer OF "basewizard.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdTable" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column1.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column1.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column2.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column2.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column3.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column3.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column4.Header1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="grdTable.Column4.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSelectAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdDeselectAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTables" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkViews" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTStampAdd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkIdentAdd" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: checkforchoosen
		*m: clear		&& Clears the contents of a ComboBox or ListBox control.
		*m: crecordsourcealias_assign
		*m: getdbcobject
		*m: getdbctables
		*m: getteblefields
		*m: setfilter
		*m: setfreetables
		*p: cchoosefield
		*p: cfieldlistalias
		*p: ckeylistalias
		*p: colddbc
		*p: coldpath
		*p: crecordsourcealias
		*p: ctablenamefield
		*p: ctruecollumnnamealias
	*</DefinedPropArrayMethod>

	cchoosefield = Export
	cfieldlistalias = crsFields
	ckeylistalias = 
	colddbc = 
	coldpath = 
	crecordsourcealias = crsTables
	ctablenamefield = TableName
	ctruecollumnnamealias = 
	Height = 282
	Name = "ctablelist"
	Width = 255

	ADD OBJECT 'chkIdentAdd' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "All", ;
		Left = 195, ;
		Name = "chkIdentAdd", ;
		ToolTipText = "Add identity column for all tables", ;
		Top = 7, ;
		Value = .T.
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTables' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Tables", ;
		Left = 0, ;
		Name = "chkTables", ;
		Top = 0, ;
		Value = .T.
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTStampAdd' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "All", ;
		Left = 147, ;
		Name = "chkTStampAdd", ;
		ToolTipText = "Add timestamp column for all tables", ;
		Top = 7, ;
		Value = .T.
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkViews' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Views", ;
		Left = 59, ;
		Name = "chkViews", ;
		Top = 0, ;
		Value = .T.
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdDeselectAll' AS basecommandbutton WITH ;
		Caption = "Deselect \<All", ;
		Left = 128, ;
		Name = "cmdDeselectAll", ;
		Top = 257, ;
		Width = 85
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSelectAll' AS basecommandbutton WITH ;
		Caption = "S\<elect All", ;
		Left = 41, ;
		Name = "cmdSelectAll", ;
		Top = 257, ;
		Width = 85
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'grdTable' AS basegrid WITH ;
		AllowHeaderSizing = .F., ;
		AllowRowSizing = .F., ;
		ColumnCount = 4, ;
		DeleteMark = .F., ;
		HeaderHeight = 30, ;
		Height = 224, ;
		HighlightStyle = 2, ;
		Left = 0, ;
		Name = "grdTable", ;
		Panel = 1, ;
		RecordMark = .F., ;
		ScrollBars = 2, ;
		SplitBar = .F., ;
		Top = 24, ;
		Width = 255, ;
		Column1.Alignment = 2, ;
		Column1.FontName = "Tahoma", ;
		Column1.FontSize = 8, ;
		Column1.Name = "Column1", ;
		Column1.Sparse = .F., ;
		Column1.Width = 19, ;
		Column2.FontName = "Tahoma", ;
		Column2.FontSize = 8, ;
		Column2.Name = "Column2", ;
		Column2.ReadOnly = .T., ;
		Column2.Width = 117, ;
		Column3.Alignment = 2, ;
		Column3.FontName = "Tahoma", ;
		Column3.FontSize = 8, ;
		Column3.Name = "Column3", ;
		Column3.Sparse = .F., ;
		Column3.Width = 44, ;
		Column4.Alignment = 2, ;
		Column4.FontName = "Tahoma", ;
		Column4.FontSize = 8, ;
		Column4.Name = "Column4", ;
		Column4.Sparse = .F., ;
		Column4.Width = 49
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="grid" />

	ADD OBJECT 'grdTable.Column1.Check1' AS basecheckbox WITH ;
		Alignment = 2, ;
		Caption = "", ;
		Centered = .T., ;
		Height = 10, ;
		Left = 13, ;
		Name = "Check1", ;
		Top = 23, ;
		Width = 10
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'grdTable.Column1.Header1' AS header WITH ;
		Caption = " ", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTable.Column2.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Tables", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1"
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTable.Column2.Text1' AS basetextbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		Enabled = .T., ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1", ;
		ReadOnly = .T.
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'grdTable.Column3.Check1' AS basecheckbox WITH ;
		Alignment = 2, ;
		Caption = "", ;
		Centered = .T., ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 17, ;
		Left = 4, ;
		Name = "Check1", ;
		Top = 23, ;
		Width = 60
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'grdTable.Column3.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Time stamp", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1", ;
		ToolTipText = "Add timestamp column", ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="header" />

	ADD OBJECT 'grdTable.Column4.Check1' AS basecheckbox WITH ;
		Alignment = 2, ;
		Caption = "", ;
		Centered = .T., ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Height = 10, ;
		Left = 0, ;
		Name = "Check1", ;
		Top = 23, ;
		Width = 10
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'grdTable.Column4.Header1' AS header WITH ;
		Alignment = 2, ;
		Caption = "Identity Column", ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		Name = "Header1", ;
		ToolTipText = "Add identity column", ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="header" />
	
	PROCEDURE checkforchoosen
		local laChosenCount[1], ;
			lcSQLStr
		laChosenCount[1] = 0
		lcSQLStr = 'select count(' + This.cChoosefield + ') from ' + ;
			This.cRecordSourceAlias + ' where ' + This.cChooseField + ;
			' into array laChosenCount'
		&lcSQLStr  
		return laChosenCount[1] <> 0
		
	ENDPROC

	PROCEDURE clear		&& Clears the contents of a ComboBox or ListBox control.
		LOCAL lnOldWorkArea as Integer
		
		lnOldWorkArea  = SELECT()
		IF USED(This.cRecordsourcealias)
			SELECT(This.cRecordsourcealias)
			ZAP
		ENDIF
		IF USED(This.cFieldlistalias)
			SELECT(This.cFieldlistalias)
			ZAP
		ENDIF
		
		SELECT(lnOldWorkArea )
	ENDPROC

	PROCEDURE crecordsourcealias_assign
		LPARAMETERS vNewVal
		*To do: Modify this routine for the Assign method
		
		WITH This.grdTable as Grid
			IF USED(vNewVal)
				LOCAL lcTagName, lcIndexExpr as String
				LOCAL liOldWorkArea, liCurrentTag as Integer
				
				liOldWorkArea = SELECT()
				lcTagName = ""
				liCurrentTag =1
				SELECT(m.vNewVal)
				DO WHILE !EMPTY(TAG(liCurrentTag))
					IF UPPER(TAG(liCurrentTag)) = "TBLORD"
						lcTagName = "TBLORD"
						EXIT 
					ENDIF
					liCurrentTag = liCurrentTag + 1
				ENDDO
				IF EMPTY(lcTagName)
					TRY 
						lcIndexExpr = "INDEX ON UPPER(ALLTRIM(" + This.cTablenamefield + ")) TAG TBLORD Additive"
						&lcIndexExpr.
						lcTagName = "TBLORD"
					CATCH
						lcTagName = ""
					ENDTRY
				ENDIF
				IF !EMPTY(lcTagName)
					SET ORDER TO TAG &lcTagName. ASCENDING 
				ENDIF
				SELECT(liOldWorkArea)
				.RecordSource = vNewVal
				.RecordSourceType = 1 && Alias
				.Column1.ControlSource = vNewVal + "." + This.cChoosefield
				.Column2.ControlSource = vNewVal+ "." + This.cTablenamefield
				.Column3.ControlSource = vNewVal+ ".TStampAdd"
				.Column4.ControlSource = vNewVal+ ".IdentAdd"		
			ELSE
				.RecordSource = ""
			ENDIF
		
			.Refresh()
		ENDWITH
		
		THIS.crecordsourcealias = m.vNewVal
	ENDPROC

	PROCEDURE getdbcobject
		LPARAMETERS taObjects, tcType, tcDirectory
		
		LOCAL lcTempAliasName, lcDirectory as String
		LOCAL loException as Exception
		
		EXTERNAL ARRAY taObjects
		
		lcDirectory = ""
		IF TYPE("tcDirectory") = "C"
			lcDirectory = ADDBS(ALLTRIM(tcDirectory))
		ENDIF
		
		lnObjectCount = ALEN(taObjects,1)
		
		FOR lnCurrentObject = 1 TO lnObjectCount
			lcObjectName = UPPER(ALLTRIM(taObjects[lnCurrentObject]))
		
			SELECT (This.Crecordsourcealias)
			LOCATE FOR UPPER(ALLTRIM(TableName)) == lcObjectName
			IF !FOUND()
				lnTableNum = RECCOUNT(This.Crecordsourcealias)
				INSERT INTO (This.Crecordsourcealias) (TableNum ,TableName, EXPORT, Type, TableNamePath) ;
							VALUES(lnTableNum, taObjects[lnCurrentObject], .T., tcType, lcDirectory)
			
				lcTempAliasName = SYS(2015)
				TRY
					USE (lcDirectory + taObjects[lnCurrentObject]) ALIAS (lcTempAliasName) AGAIN IN 0 NODATA SHARED
				CATCH TO loException
				ENDTRY
		
				IF USED(lcTempAliasName)	
					This.getteblefields(lcTempAliasName, taObjects[lnCurrentObject], lnTableNum, This.cKeylistalias, This.cTruecollumnnamealias)
					USE IN (lcTempAliasName)
				ENDIF
			ENDIF
		ENDFOR
		
	ENDPROC

	PROCEDURE getdbctables
		LPARAMETERS tcDBCName
		
		LOCAL lcOldDBC, laTables[1,1], laViews[1,1] as String
		LOCAL lnObjectCount, lnCurrentObject, lnTableNum, lnOldWorkArea as Integer
		
		IF !DBUSED(tcDBCName)
			IF FILE(tcDBCName)
				OPEN DATABASE (tcDBCName)
			ENDIF
		ENDIF
		
		IF !DBUSED(tcDBCName)
			RETURN .F.
		ENDIF
		
		lcOldDBC = SET("Database")
		lnOldWorkArea = SELECT()
		SET DATABASE TO (tcDBCName)
		
		* Get All Tables
		lnObjectCount = ADBOBJECTS(laTables,"TABLE")
		IF lnObjectCount > 0
			This.GEtdbcobject(@laTables, "T")
		ENDIF
		
		* Get Alll Views
		lnObjectCount = ADBOBJECTS(laTables,"VIEW")
		IF lnObjectCount > 0
			This.GEtdbcobject(@laTables, "V")
		ENDIF
		
		This.cOLddbc = tcDBCName
		
		SELECT(lnOldWorkArea)
		SET DATABASE TO (lcOldDBC)
	ENDPROC

	PROCEDURE getteblefields
		LPARAMETERS tcAlias, tcTableName, tnTableNum, tcKeys, tcTrueCollumnsName
		
		LOCAL lnOldAlias, lnKey, lnUpdate, lcTrueFieldName
		
		lnOldAlias = SELECT()
		SELECT(tcAlias)
		lnNumFileds = AFIELDS(aFileds)
		
		IF !EMPTY(tcKeys) AND USED(tcKeys)
			SELECT * FROM (tcKeys) WHERE UPPER(ALLTRIM(Table_Name)) == UPPER(tcTableName) ;
			INTO CURSOR crsTableKeys
		ENDIF
		
		IF !EMPTY(tcTrueCollumnsName) AND USED(tcTrueCollumnsName)
			SELECT * FROM (tcTrueCollumnsName) WHERE UPPER(ALLTRIM(Table_Name)) == UPPER(tcTableName);
			INTO CURSOR crsTrueNameTableColumns
		ENDIF
		
		FOR lnCorrentField = 1 TO lnNumFileds 
			lnKey = 0
			lnUpdate = 1
			lnRefreshField = 0
			lcFieldName = aFileds[lnCorrentField,1]
			IF USED("crsTableKeys")
				SELECT crsTableKeys
				LOCATE FOR STRTRAN(ALLTRIM(UPPER(Column_Name))," ","_") == UPPER(lcFieldName)
				IF FOUND()
					lnKey = 1
				ELSE
					lnKey = 0
				ENDIF
			ELSE
				IF (VARTYPE(tcKeys) = "C" AND !EMPTY(tcKeys) AND (UPPER(lcFieldName) $ UPPER(tcKeys)))
					lnKey = 1
				ENDIF
				lnUpdate = IIF(aFileds[lnCorrentField,18] <> 0,0,1)
				lnRefreshField = IIF(!EMPTY(aFileds[lnCorrentField,9]),1,;
									IIF(aFileds[lnCorrentField,18] <> 0,1,0))
			ENDIF
			
			IF USED("crsTrueNameTableColumns")
				SELECT crsTrueNameTableColumns
				LOCATE FOR STRTRAN(ALLTRIM(UPPER(Column_Name))," ","_") == UPPER(lcFieldName)
				IF FOUND()
					lcTrueFieldName = ALLTRIM(crsTrueNameTableColumns.Column_Name)
					IF LOWER(ALLTRIM(crsTrueNameTableColumns.Type_Name)) == "int identity"
						lnUpdate = 0
						lnRefreshField = 1
					ENDIF
				ELSE
					lcTrueFieldName = lcFieldName
				ENDIF
			ELSE
				lcTrueFieldName = lcFieldName
			ENDIF
		
			INSERT INTO crsFields(TableNum , FieldNum , FieldKey , FieldUpdate , FieldRefresh,;
						FieldName,  FoxFieldName , FieldType , FieldLen ,;
						FieldDec );
						VALUES(tnTableNum, lnCorrentField, lnKey, lnUpdate,lnRefreshField, ;
						lcTrueFieldName, lcFieldName, aFileds[lnCorrentField,2],;
						aFileds[lnCorrentField,3], aFileds[lnCorrentField,4])
		ENDFOR
		RELEASE aFileds
		
		IF USED("crsTableKeys")
			USE IN crsTableKeys
		ENDIF
		IF USED("crsTrueNameTableColumns")
			USE IN crsTrueNameTableColumns
		ENDIF
		SELECT(lnOldAlias)
	ENDPROC

	PROCEDURE Init
		IF !USED(This.cRecordsourcealias)
			CREATE CURSOR (This.cRecordsourcealias) (TableNum I,TableName c(250), CAClassName c(250), EXPORT L, Type C(1), TableNamePath M)
		ENDIF
		
		*!*	IF !USED(This.cFieldlistalias)
		*!*		CREATE CURSOR (This.cFieldlistalias) (TableNum I, FieldNum I, FieldKey n(1), FieldUpdate n(1), ;
		*!*												FieldRefresh n(1), FieldName c(250), FoxFieldName c(250), ;
		*!*												FieldType c(10), FieldLen n(10), FieldDec n(10))
		*!*	ENDIF
		
		*!*	This.grdTable.RecordSource = This.cRecordsourcealias
		*!*	This.grdTable.RecordSourceType = 1 && Alias
		*!*	This.GrdTable.Column1.ControlSource = This.cRecordsourcealias+ ".EXPORT"
		*!*	This.GrdTable.Column2.ControlSource = This.cRecordsourcealias+ ".TableName"
		
		This.grdTable.Refresh()
		
		This.Setfilter()
		
	ENDPROC

	PROCEDURE setfilter
		LOCAL lcFilterExp, lcOR as String
		LOCAL lnOldWorkArea as Integer
		
		lcOR = ""
		lnOldWorkArea = SELECT()
		lcFilterExp = ""
		
		IF This.ChkTables.Value = .t.
			lcFilterExp = "Type == 'T'"
			lcOR = " or "
		ENDIF
		IF This.chkViews.Value = .T.
			lcFilterExp = lcFilterExp  + lcOR + "Type == 'V'"
		ENDIF
		
		SELECT(This.cRecordsourcealias)
		IF EMPTY(lcFilterExp)
			lcFilterExp = "Type = 'X'"
		ENDIF
		SET FILTER TO &lcFilterExp
		LOCATE
		This.grdTable.Refresh()
		
		SELECT(lnOldWorkArea)
	ENDPROC

	PROCEDURE setfreetables
		LPARAMETERS tcDirectory
		
		LOCAL laFreeTableList[1,1] as String
		LOCAL lnTablesCount as Integer
		
		IF !DIRECTORY(tcDirectory, .t.)
			RETURN .t.
		ENDIF
		
		lnTablesCount = ADIR(laFreeTableList,  ADDBS(tcDirectory) + "*.DBF")
		
		IF lnTablesCount > 0 
			This.Getdbcobject(@laFreeTableList, "T", tcDirectory)
		ENDIF
	ENDPROC

	PROCEDURE chkIdentAdd.InteractiveChange
		LOCAL lnOldWorkArea, lnOldRecno as Integer
		
		lnOldWorkArea  = SELECT()
		lnOldRecno = RECNO(This.Parent.crecordsourcealias)
		Replace IdentAdd WITH This.Value ALL IN (This.Parent.crecordsourcealias)
		
		SELECT(This.Parent.crecordsourcealias)
		IF RECCOUNT() >= lnOldRecno 
			GOTO lnOldRecno  
		ELSE
			LOCATE
		ENDIF
		
		This.Parent.grDTABLE.Refresh()
		
		SELECT(lnOldWorkArea )
	ENDPROC

	PROCEDURE chkTables.InteractiveChange
		This.Parent.Setfilter()
	ENDPROC

	PROCEDURE chkTStampAdd.InteractiveChange
		LOCAL lcOldWorkArea, lnOldRecno as Integer
		
		lcOldWorkArea =SELECT()
		lnOldRecno = RECNO(This.Parent.crecordsourcealias)
		Replace TStampAdd WITH This.Value ALL IN (This.Parent.crecordsourcealias)
		SELECT(This.Parent.crecordsourcealias)
		IF RECCOUNT() >= lnOldRecno
			GOTO lnOldRecno
		ELSE
			LOCATE
		ENDIF
		This.Parent.grDTABLE.Refresh()
		
		SELECT(lcOldWorkArea)
	ENDPROC

	PROCEDURE chkViews.InteractiveChange
		This.Parent.Setfilter()
	ENDPROC

	PROCEDURE cmdDeselectAll.Click
		LOCAL lnOldWorkArea, lnRecno as Integer
		
		lnOldWorkArea = SELECT()
		SELECT(This.Parent.cRecordsourcealias)
		lnRecno = RECNO()
		Replace EXPORT WITH .F. ALL IN (This.Parent.cRecordsourcealias)
		IF RECCOUNT() >= lnRecno
			GO lnRecno
		ENDIF
		SELECT(lnOldWorkArea)
		Thisform.lTableChosen = .F.
		Thisform.RefreshSteps()
		
	ENDPROC

	PROCEDURE cmdSelectAll.Click
		LOCAL lnOldWorkArea, lnRecno as Integer
		
		lnOldWorkArea = SELECT()
		SELECT(This.Parent.cRecordsourcealias)
		lnRecno = RECNO()
		Replace EXPORT WITH .T. ALL IN (This.Parent.cRecordsourcealias)
		IF RECCOUNT() >= lnRecno
			GO lnRecno
		ENDIF
		SELECT(lnOldWorkArea)
		Thisform.lTableChosen = This.Parent.CheckForChoosen()
		Thisform.RefreshSteps()
		
	ENDPROC

	PROCEDURE grdTable.Column1.Check1.InteractiveChange
		local lcAlias, ;
			lcField
		lcAlias = juststem(This.Parent.ControlSource)
		lcField = justext(This.Parent.ControlSource)
		replace (lcField) with This.Value in (lcAlias)
		Thisform.lTableChosen = This.Parent.Parent.Parent.CheckForChoosen()
		Thisform.RefreshSteps()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS exportoptions AS basecontainer OF "basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Baseshape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baseshape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Wizshape1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Wizshape2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkValidation" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkDefaults" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkIndexes" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkRemotizeViews" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkReport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkRelations" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkStructureOnly" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkTableToView" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkSavePwd" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkExportDRI" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Combo1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Wizlabel3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdAdvanced" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Wizlabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkBlankDates" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Wizlabel2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkBulkInsert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblReportOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Baselabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtReportDir" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblReportDir" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdReportDir" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="txtServerTempFolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblServerTempFolder" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\alldefs.h"
	*<DefinedPropArrayMethod>
		*m: setoptions
	*</DefinedPropArrayMethod>

	Height = 271
	Name = "exportoptions"
	Width = 602

	ADD OBJECT 'Baselabel1' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Data upload options: ", ;
		Left = 6, ;
		Name = "Baselabel1", ;
		Style = 3, ;
		TabIndex = 15, ;
		Top = 153, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Baseshape1' AS baseshape WITH ;
		Height = 65, ;
		Left = 0, ;
		Name = "Baseshape1", ;
		Style = 3, ;
		Top = 160, ;
		Width = 263, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />

	ADD OBJECT 'Baseshape2' AS baseshape WITH ;
		Height = 65, ;
		Left = 270, ;
		Name = "Baseshape2", ;
		Style = 3, ;
		Top = 160, ;
		Width = 325, ;
		ZOrderSet = 0
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />

	ADD OBJECT 'chkBlankDates' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Upsi\<ze blank dates as NULL", ;
		Left = 10, ;
		Name = "chkBlankDates", ;
		TabIndex = 18, ;
		Top = 195, ;
		Value = .T., ;
		ZOrderSet = 17
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkBulkInsert' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Use \<bulk insert for fast data upload", ;
		ControlSource = "Thisform.lUseBulkInsert", ;
		Left = 10, ;
		Name = "chkBulkInsert", ;
		TabIndex = 17, ;
		Top = 175, ;
		ZOrderSet = 19
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkDefaults' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Defaults", ;
		Left = 10, ;
		Name = "chkDefaults", ;
		TabIndex = 4, ;
		Top = 70, ;
		ZOrderSet = 4
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkExportDRI' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Use declarative RI", ;
		Left = 110, ;
		Name = "chkExportDRI", ;
		TabIndex = 7, ;
		Top = 90, ;
		ZOrderSet = 12
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkIndexes' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Indexes", ;
		Left = 10, ;
		Name = "chkIndexes", ;
		TabIndex = 2, ;
		Top = 50, ;
		ZOrderSet = 5
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkRelations' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Relationships", ;
		Left = 10, ;
		Name = "chkRelations", ;
		TabIndex = 6, ;
		Top = 90, ;
		ZOrderSet = 7
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkRemotizeViews' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Redirec\<t views to remote data", ;
		Left = 280, ;
		Name = "chkRemotizeViews", ;
		TabIndex = 11, ;
		Top = 55, ;
		ZOrderSet = 6
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkReport' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Create upsizing re\<port", ;
		ControlSource = "Thisform.oEngine.DoReport", ;
		Left = 280, ;
		Name = "chkReport", ;
		TabIndex = 19, ;
		Top = 175, ;
		ZOrderSet = 8
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkSavePwd' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Save pass\<word with views", ;
		Left = 280, ;
		Name = "chkSavePwd", ;
		TabIndex = 13, ;
		Top = 95, ;
		ZOrderSet = 11
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkStructureOnly' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Structure only, no data", ;
		Left = 110, ;
		Name = "chkStructureOnly", ;
		TabIndex = 5, ;
		Top = 70, ;
		ZOrderSet = 9
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkTableToView' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "Create re\<mote views on tables", ;
		Left = 280, ;
		Name = "chkTableToView", ;
		TabIndex = 12, ;
		Top = 75, ;
		ZOrderSet = 10
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkValidation' AS basecheckbox WITH ;
		Alignment = 0, ;
		Caption = "\<Validation rules", ;
		Left = 110, ;
		Name = "chkValidation", ;
		TabIndex = 3, ;
		Top = 50, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="checkbox" />

	ADD OBJECT 'cmdAdvanced' AS basecommandbutton WITH ;
		Caption = "\<Advanced...", ;
		Left = 520, ;
		Name = "cmdAdvanced", ;
		TabIndex = 14, ;
		Top = 0, ;
		ZOrderSet = 15
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdReportDir' AS basewizardcommandbutton WITH ;
		Caption = "...", ;
		Height = 22, ;
		Left = 565, ;
		Name = "cmdReportDir", ;
		TabIndex = 22, ;
		Top = 195, ;
		Width = 22
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'Combo1' AS basecombobox WITH ;
		Height = 22, ;
		Left = 90, ;
		Name = "Combo1", ;
		RowSource = "General fields override,General and memo fields override,All fields override,Default settings", ;
		RowSourceType = 1, ;
		TabIndex = 9, ;
		Top = 115, ;
		Width = 160, ;
		ZOrderSet = 13
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="combobox" />

	ADD OBJECT 'lblReportDir' AS basewizardlabel WITH ;
		Caption = "\<Output folder", ;
		Left = 280, ;
		Name = "lblReportDir", ;
		TabIndex = 20, ;
		Top = 199
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'lblReportOptions' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Report options: ", ;
		Left = 276, ;
		Name = "lblReportOptions", ;
		Style = 3, ;
		TabIndex = 16, ;
		Top = 153, ;
		ZOrderSet = 20
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblServerTempFolder' AS basewizardlabel WITH ;
		Caption = "Server temp folder", ;
		Left = 0, ;
		Name = "lblServerTempFolder", ;
		TabIndex = 23, ;
		Top = 244
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="label" />

	ADD OBJECT 'txtReportDir' AS basewizardtextbox WITH ;
		ControlSource = "Thisform.oEngine.ReportDir", ;
		Height = 22, ;
		Left = 350, ;
		Name = "txtReportDir", ;
		TabIndex = 21, ;
		Top = 195, ;
		Width = 215
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="textbox" />

	ADD OBJECT 'txtServerTempFolder' AS basewizardtextbox WITH ;
		ControlSource = "Thisform.oEngine.ServerTempFolder", ;
		Height = 22, ;
		Left = 95, ;
		Name = "txtServerTempFolder", ;
		TabIndex = 24, ;
		Top = 240, ;
		Width = 295
		*< END OBJECT: ClassLib="basewizard.vcx" BaseClass="textbox" />

	ADD OBJECT 'Wizlabel1' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Table attributes to upsize: ", ;
		Left = 6, ;
		Name = "Wizlabel1", ;
		Style = 3, ;
		TabIndex = 1, ;
		Top = 28, ;
		ZOrderSet = 16
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Wizlabel2' AS baselabel WITH ;
		BackStyle = 1, ;
		Caption = " Changes to make locally: ", ;
		Left = 276, ;
		Name = "Wizlabel2", ;
		Style = 3, ;
		TabIndex = 10, ;
		Top = 28, ;
		ZOrderSet = 18
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Wizlabel3' AS baselabel WITH ;
		Caption = "\<Null mapping:", ;
		Left = 10, ;
		Name = "Wizlabel3", ;
		TabIndex = 8, ;
		Top = 119, ;
		ZOrderSet = 14
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'Wizshape1' AS baseshape WITH ;
		Height = 109, ;
		Left = 0, ;
		Name = "Wizshape1", ;
		Style = 3, ;
		Top = 35, ;
		Width = 263, ;
		ZOrderSet = 1
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />

	ADD OBJECT 'Wizshape2' AS baseshape WITH ;
		Height = 109, ;
		Left = 270, ;
		Name = "Wizshape2", ;
		Style = 3, ;
		Top = 35, ;
		Width = 325, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="shape" />
	
	PROCEDURE setoptions
		LOCAL llPwdInDef
		
		*Because setting the value of check boxes fires the click event,
		*this routine will cause an infinite loop without this flag
		Thisform.oEngine.RealClick=.F.
		
		WITH This
			*Make sure color of opaque labels is right
			.Wizlabel1.BackColor = this.backcolor
			.Wizlabel2.BackColor = this.backcolor
				
			.chkRelations.value = Thisform.oEngine.ExportRelations
			.chkStructureOnly.value = Thisform.oEngine.ExportStructureOnly
			.chkReport.value = Thisform.oEngine.DoReport
			.chkRemotizeViews.value =Thisform.oEngine.ExportViewToRmt
			.chkTableToView.value = Thisform.oEngine.ExportTableToView
			.chkIndexes.value = Thisform.oEngine.ExportIndexes
			.chkDefaults.value = Thisform.oEngine.ExportDefaults
			.chkValidation.value = Thisform.oEngine.ExportValidation
		
			*If the user is upsizing with a connection def, it will not
			*have a password added or removed from it.  Any connections created
			*will have a password saved only if the original conn def had a pwd.
		
		
			IF !Thisform.oEngine.UserConnection=="" THEN
				Thisform.oEngine.PwdInDef=!EMPTY(DBGETPROP(Thisform.oEngine.UserConnection,"connection","password"))
			ELSE
				Thisform.oEngine.PwdInDef=.F.
			ENDIF
		
			IF (Thisform.oEngine.ExportViewToRmt OR Thisform.oEngine.ExportTableToView)
				IF Thisform.oEngine.UserConnection=="" 
					.chkSavePwd.enabled=.T.
					.chkSavePwd.value=Thisform.oEngine.ExportSavePwd	
				ELSE
					.chkSavePwd.enabled=.F.
					.chkSavePwd.value=Thisform.oEngine.PwdInDef
				ENDIF
			ELSE
				.chkSavePwd.enabled=.F.
				.chkSavePwd.value=.F.
			ENDIF
		
			Thisform.oEngine.RealClick=.T.
		
			*DRI check box should be enabled if Oracle or SQL '95
			IF !Thisform.oEngine.ServerType=="SQL Server" THEN
				.chkExportDRI.enabled=.T.
				.chkExportDRI.value=Thisform.oEngine.ExportDRI
			ELSE
				.chkExportDRI.enabled=.F.
				.chkExportDRI.value=.F.
			ENDIF
		ENDWITH 
	ENDPROC

	PROCEDURE chkBlankDates.Click
		Thisform.oEngine.BlankDateValue = iif(This.Value, .NULL., ;
			SQL_SERVER_EMPTY_DATE_Y2K)
		
	ENDPROC

	PROCEDURE chkDefaults.Click
		Thisform.oEngine.ExportDefaults=this.value
		
	ENDPROC

	PROCEDURE chkExportDRI.Click
		Thisform.oEngine.ExportDRI=this.value
		
	ENDPROC

	PROCEDURE chkIndexes.Click
		Thisform.oEngine.ExportIndexes=this.value
		
	ENDPROC

	PROCEDURE chkRelations.Click
		Thisform.oEngine.ExportRelations=this.value
		
		IF Thisform.oEngine.ServerType=="Oracle" OR Thisform.oEngine.ServerType=="SQL Server95" THEN
			IF !this.value THEN
				this.parent.chkExportDRI.enabled=.F.
				this.parent.chkExportDRI.value=.F.
			ELSE
				this.parent.chkExportDRI.enabled=.T.
				this.parent.chkExportDRI.value=Thisform.oEngine.ExportDRI
			ENDIF
		ELSE
			this.parent.chkExportDRI.enabled=.F.
			this.parent.chkExportDRI.value=.F.
		ENDIF	
		
	ENDPROC

	PROCEDURE chkRemotizeViews.Click
		Thisform.oEngine.ExportViewToRmt=this.value
		
		Thisform.oEngine.RealClick=.F.
		
		IF (Thisform.oEngine.ExportViewToRmt OR Thisform.oEngine.ExportTableToView)
			IF Thisform.oEngine.UserConnection=="" 
				this.parent.chkSavePwd.enabled=.T.
				this.parent.chkSavePwd.value=Thisform.oEngine.ExportSavePwd	
			ELSE
				this.parent.chkSavePwd.enabled=.F.
				this.parent.chkSavePwd.value=Thisform.oEngine.PwdInDef
			ENDIF
		ELSE
			this.parent.chkSavePwd.enabled=.F.
			this.parent.chkSavePwd.value=.F.
		ENDIF
		
		Thisform.oEngine.RealClick=.T.
	ENDPROC

	PROCEDURE chkSavePwd.Click
		IF !Thisform.oEngine.RealClick THEN
			RETURN
		ENDIF
		Thisform.oEngine.ExportSavePwd=this.value
	ENDPROC

	PROCEDURE chkStructureOnly.Click
		Thisform.oEngine.ExportStructureOnly=this.value
		
	ENDPROC

	PROCEDURE chkTableToView.Click
		Thisform.oEngine.ExportTableToView=this.value
		
		Thisform.oEngine.RealClick=.F.
		
		IF (Thisform.oEngine.ExportViewToRmt OR Thisform.oEngine.ExportTableToView)
			IF Thisform.oEngine.UserConnection=="" 
				this.parent.chkSavePwd.enabled=.T.
				this.parent.chkSavePwd.value=Thisform.oEngine.ExportSavePwd	
			ELSE
				this.parent.chkSavePwd.enabled=.F.
				this.parent.chkSavePwd.value=Thisform.oEngine.PwdInDef
			ENDIF
		ELSE
			this.parent.chkSavePwd.enabled=.F.
			this.parent.chkSavePwd.value=.F.
		ENDIF
		
		Thisform.oEngine.RealClick=.T.
	ENDPROC

	PROCEDURE chkValidation.Click
		Thisform.oEngine.ExportValidation=this.value
		
	ENDPROC

	PROCEDURE cmdAdvanced.Click
		local loAdvanced
		loAdvanced = newobject('Advanced', 'upswiz.vcx', '', This.Parent, Thisform.oEngine)
		loAdvanced.Show()
		
	ENDPROC

	PROCEDURE cmdReportDir.Click
		lcFolder = getdir(Thisform.oEngine.ReportDir, '', 'Select Report Folder', 64)
		if not empty(lcFolder)
			store lcFolder to Thisform.oEngine.ReportDir, This.Parent.txtReportDir.Value
		endif not empty(lcFolder)
		
	ENDPROC

	PROCEDURE Combo1.Init
		THIS.Value = THIS.List[1]
	ENDPROC

	PROCEDURE Combo1.InteractiveChange
		Thisform.oEngine.NullOverride=this.ListIndex
		
	ENDPROC

	PROCEDURE txtReportDir.Init
		* Set value to itself so ProgrammaticChange fires.
		
		This.Value = This.Value
		
	ENDPROC

	PROCEDURE txtReportDir.ProgrammaticChange
		try
			This.ToolTipText = displaypath(This.Value, 127)
		catch
		endtry
		
	ENDPROC

ENDDEFINE

DEFINE CLASS progressbar AS basecontainer OF "basecontrols.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="oProgress" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTitle" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblTask" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\upsizing.h"
	*<DefinedPropArrayMethod>
		*m: completeprocess		&& Completes a process
		*m: initprocess		&& Initializes the progress bar for a process
		*m: updateprocess		&& Updates the progress bar for a process
	*</DefinedPropArrayMethod>

	Height = 65
	Name = "progressbar"
	Width = 399
	_memberdata = <VFPData>
		<memberdata name="initprocess" type="method" display="InitProcess"/>
		<memberdata name="updateprocess" type="method" display="UpdateProcess"/>
		<memberdata name="completeprocess" type="method" display="CompleteProcess"/>
		</VFPData>

	ADD OBJECT 'lblTask' AS baselabel WITH ;
		AutoSize = .F., ;
		Height = 15, ;
		Left = 0, ;
		Name = "lblTask", ;
		Top = 15, ;
		Width = 395
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'lblTitle' AS baselabel WITH ;
		AutoSize = .F., ;
		Height = 15, ;
		Left = 0, ;
		Name = "lblTitle", ;
		Top = 0, ;
		Width = 395
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'oProgress' AS sfprogressbar WITH ;
		bars = 60, ;
		Left = 0, ;
		Name = "oProgress", ;
		showpercentage = .T., ;
		Top = 40, ;
		Width = 395
		*< END OBJECT: ClassLib="sfprogressbar.vcx" BaseClass="container" />
	
	PROCEDURE completeprocess		&& Completes a process
		lparameters tcTask
		local lcTask, ;
			lnSeconds
		if pcount() = 0
			lcTask = THERMCOMPLETE_LOC
		else
			lcTask = tcTask
		endif pcount() = 0
		This.UpdateProcess(This.oProgress.Max, lcTask)
		lnSeconds = seconds() + 1
		do while seconds() < lnSeconds
			*- wait a sec
		enddo
		
	ENDPROC

	PROCEDURE initprocess		&& Initializes the progress bar for a process
		lparameters tcTitle, ;
			tnBasis
		with This
			.lblTitle.Caption = iif(empty(tcTitle), '', tcTitle)
			.lblTask.Caption  = ''
			.oProgress.Max    = iif(empty(tnBasis), 100, tnBasis)
			.oProgress.Value  = 0
		endwith
		
	ENDPROC

	PROCEDURE updateprocess		&& Updates the progress bar for a process
		lparameters tnProgress, ;
			tcTask
		if not This.Visible
			This.Visible = .T.
		endif not This.Visible
		This.oProgress.Value = tnProgress
		if vartype(tcTask) = 'C' and not This.lblTask.Caption == tcTask
			This.lblTask.Caption = tcTask
		endif vartype(tcTask) = 'C' ...
		
	ENDPROC

ENDDEFINE

DEFINE CLASS upsizingwizardform AS basewizardform OF "basewizard.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="pgfWizard.BASEPAGE1.ChooseSourceDB" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.BASEPAGE1.Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.BASEPAGE1.Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage2.Cconnstr" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage2.Label9" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage2.Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage3.Choosetargetdb" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage3.Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage3.Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.cTableList" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Cfieldtypemap" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcFldName.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcFldName.Basetextbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcType.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcType.Basetextbox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage5.ExportOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage5.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage5.Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage6.opgOutputType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage6.Image1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage6.Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="pgfWizard.Basepage6.oProgress" UniqueID="" Timestamp="" />

	#INCLUDE "..\include\upsizing.h"
	*<DefinedPropArrayMethod>
		*m: analysiscleanup		&& Clean up analysis tables
		*m: checkdestination		&& Determines if the destination information is complete
		*m: completeprocess		&& Completes the progress bar for a process
		*m: initprocess		&& Initialize the progress bar for a process
		*m: setsourcedatabase		&& Sets cSourceDatabase to the specified value
		*m: updateprocess		&& Update the progress bar for a process
		*p: cconnection		&& The connection to use
		*p: cconnectiondatabase		&& The database to use for connections
		*p: cconnstring		&& The connection string to use
		*p: cdsn		&& The DSN to use
		*p: cdsnpassword		&& The password to use for the DSN
		*p: cdsnusername		&& The user name to use for the DSN
		*p: cnewtargetdatabase		&& The name of a new database to upsize to
		*p: cpath		&& The current path
		*p: cserver		&& The server to use
		*p: cserverpassword		&& The password to use for the server
		*p: cserverusername		&& The user name to use for the server
		*p: csourcedatabase		&& The source database to upsize
		*p: ctargetdatabase		&& The database to upsize to
		*p: lneedreloadfields		&& .T. if we need to reload fields because the user changed source databases
		*p: ltablechosen		&& .T. if a table was chosen
		*p: ltargetdatabasevalid		&& .T. if the target database is valid
		*p: ltrustedconnection		&& .T. to use a trusted connection
		*p: lusebulkinsert		&& .T. to use bulk insert
		*p: nconnectiontype		&& The type of connection to use: 1 = database connection, 2 = ODBC
		*p: ndatabasetype		&& The database to upsize to: 1 = existing, 2 = new
		*p: nodbctype		&& The type of ODBC connection to use: 1 = DSN, 2 = server information, 3 = connection string
		*p: oengine		&& A reference to an UpsizeEngine object
	*</DefinedPropArrayMethod>

	BorderStyle = 2
	Caption = "Upsizing Wizard"
	cconnection = 		&& The connection to use
	cconnectiondatabase = 		&& The database to use for connections
	cconnstring = 		&& The connection string to use
	cdsn = 		&& The DSN to use
	cdsnpassword = 		&& The password to use for the DSN
	cdsnusername = 		&& The user name to use for the DSN
	cnewtargetdatabase = 		&& The name of a new database to upsize to
	cpath = 		&& The current path
	cserver = 		&& The server to use
	cserverpassword = 		&& The password to use for the server
	cserverusername = 		&& The user name to use for the server
	csourcedatabase = 		&& The source database to upsize
	ctargetdatabase = 		&& The database to upsize to
	DoCreate = .T.
	Height = 504
	HelpContextID = 1999945411
	lneedreloadfields = .F.		&& .T. if we need to reload fields because the user changed source databases
	lsavesettings = .F.
	ltablechosen = .F.		&& .T. if a table was chosen
	ltargetdatabasevalid = .F.		&& .T. if the target database is valid
	ltrustedconnection = .F.		&& .T. to use a trusted connection
	lusebulkinsert = .T.		&& .T. to use bulk insert
	MaxButton = .F.
	MinButton = .F.
	Name = "upsizingwizardform"
	nconnectiontype = 2		&& The type of connection to use: 1 = database connection, 2 = ODBC
	ndatabasetype = 0		&& The database to upsize to: 1 = existing, 2 = new
	nmaxsteps = 6
	nodbctype = 1		&& The type of ODBC connection to use: 1 = DSN, 2 = server information, 3 = connection string
	oengine = .NULL.		&& A reference to an UpsizeEngine object
	Width = 780
	WindowType = 1
	_memberdata = <VFPData>
		<memberdata name="asteps" type="property" display="aSteps"/>
		<memberdata name="ccurrhelp" type="property" display="cCurrHelp"/>
		<memberdata name="ccurrhelpfile" type="property" display="cCurrHelpFile"/>
		<memberdata name="chelpfile" type="property" display="cHelpFile" favorites="True"/>
		<memberdata name="finish" type="method" display="Finish" favorites="True"/>
		<memberdata name="isstepenabled" type="method" display="IsStepEnabled"/>
		<memberdata name="lcancel" type="property" display="lCancel"/>
		<memberdata name="lfinish" type="property" display="lFinish"/>
		<memberdata name="loadstepscombo" type="method" display="LoadStepsCombo"/>
		<memberdata name="ncurrentstep" type="property" display="nCurrentStep"/>
		<memberdata name="nformerstep" type="property" display="nFormerStep"/>
		<memberdata name="nmaxsteps" type="property" display="nMaxSteps" favorites="True"/>
		<memberdata name="refreshsteps" type="method" display="RefreshSteps"/>
		<memberdata name="restorehelp" type="method" display="RestoreHelp"/>
		<memberdata name="save" type="method" display="Save"/>
		<memberdata name="selectstep" type="method" display="SelectStep"/>
		<memberdata name="sethelp" type="method" display="SetHelp"/>
		<memberdata name="setupsteps" type="method" display="SetupSteps" favorites="True"/>
		<memberdata name="stepdone" type="method" display="StepDone" favorites="True"/>
		<memberdata name="stepselected" type="method" display="StepSelected"/>
		<memberdata name="validatecurrentcontrol" type="method" display="ValidateCurrentControl"/>
		<memberdata name="cancel" type="method" display="Cancel"/>
		<memberdata name="cregistrykey" type="property" display="cRegistryKey"/>
		<memberdata name="csourcedatabase" type="property" display="cSourceDatabase"/>
		<memberdata name="cconnectiondatabase" type="property" display="cConnectionDatabase"/>
		<memberdata name="cconnection" type="property" display="cConnection"/>
		<memberdata name="cdsn" type="property" display="cDSN"/>
		<memberdata name="cdsnusername" type="property" display="cDSNUserName"/>
		<memberdata name="cdsnpassword" type="property" display="cDSNPassword"/>
		<memberdata name="cserver" type="property" display="cServer"/>
		<memberdata name="cserverusername" type="property" display="cServerUserName"/>
		<memberdata name="cserverpassword" type="property" display="cServerPassword"/>
		<memberdata name="cconnstring" type="property" display="cConnString"/>
		<memberdata name="nodbctype" type="property" display="nODBCType"/>
		<memberdata name="nconnectiontype" type="property" display="nConnectionType"/>
		<memberdata name="ltrustedconnection" type="property" display="lTrustedConnection"/>
		<memberdata name="checkdestination" type="method" display="CheckDestination"/>
		<memberdata name="ctargetdatabase" type="property" display="cTargetDatabase"/>
		<memberdata name="cnewtargetdatabase" type="property" display="cNewTargetDatabase"/>
		<memberdata name="ndatabasetype" type="property" display="nDatabaseType"/>
		<memberdata name="lneedreloadfields" type="property" display="lNeedReloadFields"/>
		<memberdata name="analysiscleanup" type="method" display="AnalysisCleanup"/>
		<memberdata name="oengine" type="property" display="oEngine"/>
		<memberdata name="cpath" type="property" display="cPath"/>
		<memberdata name="ltablechosen" type="property" display="lTableChosen"/>
		<memberdata name="ltargetdatabasevalid" type="property" display="lTargetDatabaseValid"/>
		<memberdata name="lusebulkinsert" type="property" display="lUseBulkInsert"/>
		<memberdata name="initprocess" type="method" display="InitProcess"/>
		<memberdata name="updateprocess" type="method" display="UpdateProcess"/>
		<memberdata name="completeprocess" type="method" display="CompleteProcess"/>
		<memberdata name="setsourcedatabase" type="method" display="SetSourceDatabase"/>
		</VFPData>
	cboSteps.Height = 22
	cboSteps.Left = 160
	cboSteps.Name = "cboSteps"
	cboSteps.Top = 20
	cboSteps.Width = 600
	cmdBack.Left = 525
	cmdBack.Name = "cmdBack"
	cmdBack.Top = 465
	cmdCancel.Left = 445
	cmdCancel.Name = "cmdCancel"
	cmdCancel.Top = 465
	cmdFinish.Left = 685
	cmdFinish.Name = "cmdFinish"
	cmdFinish.Top = 465
	cmdHelp.Name = "cmdHelp"
	cmdHelp.Top = 465
	cmdNext.Left = 605
	cmdNext.Name = "cmdNext"
	cmdNext.Top = 465
	pgfWizard.BASEPAGE1.Name = "BASEPAGE1"
	pgfWizard.Basepage2.Caption = "Basepage2"
	pgfWizard.Basepage2.Name = "Basepage2"
	pgfWizard.Basepage3.Caption = "Basepage3"
	pgfWizard.Basepage3.Name = "Basepage3"
	pgfWizard.Basepage4.Caption = "Basepage4"
	pgfWizard.Basepage4.Name = "Basepage4"
	pgfWizard.Basepage5.Caption = "Basepage5"
	pgfWizard.Basepage5.Name = "Basepage5"
	pgfWizard.Basepage6.Caption = "Basepage6"
	pgfWizard.Basepage6.Name = "Basepage6"
	pgfWizard.ErasePage = .T.
	pgfWizard.Height = 504
	pgfWizard.Name = "pgfWizard"
	pgfWizard.PageCount = 6
	pgfWizard.Top = 0
	pgfWizard.Width = 770
	shpSeparator.Name = "shpSeparator"
	shpSeparator.Top = 450
	shpSeparator.Width = 750

	ADD OBJECT 'pgfWizard.BASEPAGE1.ChooseSourceDB' AS choosesourcedb WITH ;
		Left = 160, ;
		Name = "ChooseSourceDB", ;
		Top = 95, ;
		CMDOPEN.Name = "CMDOPEN", ;
		LSTLIST.Name = "LSTLIST", ;
		WIZLABEL1.Name = "WIZLABEL1"
		*< END OBJECT: ClassLib="upswiz.vcx" BaseClass="container" />

	ADD OBJECT 'pgfWizard.BASEPAGE1.Image1' AS baseimage WITH ;
		Height = 124, ;
		Left = 10, ;
		Name = "Image1", ;
		Picture = ..\bitmap\upsize1.bmp, ;
		Top = 20, ;
		Width = 139
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'pgfWizard.BASEPAGE1.Label3' AS baselabel WITH ;
		Caption = "Which local database do you want to upsize?", ;
		Height = 15, ;
		Left = 160, ;
		Name = "Label3", ;
		Top = 50, ;
		Width = 217
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfWizard.Basepage2.Cconnstr' AS cconnstr WITH ;
		Left = 160, ;
		Name = "Cconnstr", ;
		Top = 65, ;
		CHKUSETC.Alignment = 0, ;
		CHKUSETC.Name = "CHKUSETC", ;
		CMBCONNECTIONS.Name = "CMBCONNECTIONS", ;
		CMBDSN.Name = "CMBDSN", ;
		CMBSERVERS.Name = "CMBSERVERS", ;
		CMDGETDBC.Name = "CMDGETDBC", ;
		EDTDATABASE.Name = "EDTDATABASE", ;
		EDTUSERCONNSTR.Name = "EDTUSERCONNSTR", ;
		LBLCONNECTIONS.Name = "LBLCONNECTIONS", ;
		LBLDSN.Name = "LBLDSN", ;
		LBLDSNPASSWORD.Name = "LBLDSNPASSWORD", ;
		LBLDSNUSERNAME.Name = "LBLDSNUSERNAME", ;
		LBLSERVERPWD.Name = "LBLSERVERPWD", ;
		LBLSERVERS.Name = "LBLSERVERS", ;
		LBLSERVERUID.Name = "LBLSERVERUID", ;
		OPGCONNECTION.baseoptionbutton1.Left = 5, ;
		OPGCONNECTION.baseoptionbutton1.Name = "baseoptionbutton1", ;
		OPGCONNECTION.baseoptionbutton1.Top = 5, ;
		OPGCONNECTION.baseoptionbutton2.Left = 5, ;
		OPGCONNECTION.baseoptionbutton2.Name = "baseoptionbutton2", ;
		OPGCONNECTION.baseoptionbutton2.Top = 80, ;
		OPGCONNECTION.Name = "OPGCONNECTION", ;
		OPGODBCTYPE.baseoptionbutton1.Left = 5, ;
		OPGODBCTYPE.baseoptionbutton1.Name = "baseoptionbutton1", ;
		OPGODBCTYPE.baseoptionbutton1.Top = 4, ;
		OPGODBCTYPE.baseoptionbutton2.Left = 5, ;
		OPGODBCTYPE.baseoptionbutton2.Name = "baseoptionbutton2", ;
		OPGODBCTYPE.baseoptionbutton2.Top = 59, ;
		OPGODBCTYPE.Baseoptionbutton3.Left = 5, ;
		OPGODBCTYPE.Baseoptionbutton3.Name = "Baseoptionbutton3", ;
		OPGODBCTYPE.Baseoptionbutton3.Top = 164, ;
		OPGODBCTYPE.Name = "OPGODBCTYPE", ;
		TXTDSNPASSWORD.Name = "TXTDSNPASSWORD", ;
		TXTDSNUSERNAME.Name = "TXTDSNUSERNAME", ;
		TXTSERVERPWD.Name = "TXTSERVERPWD", ;
		TXTSERVERUID.Name = "TXTSERVERUID"
		*< END OBJECT: ClassLib="upswiz.vcx" BaseClass="container" />

	ADD OBJECT 'pgfWizard.Basepage2.Image1' AS baseimage WITH ;
		Height = 124, ;
		Left = 10, ;
		Name = "Image1", ;
		Picture = ..\bitmap\upsize23.bmp, ;
		Top = 20, ;
		Width = 139
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'pgfWizard.Basepage2.Label9' AS baselabel WITH ;
		Caption = "Which data source do you want to upsize your database to?", ;
		Left = 160, ;
		Name = "Label9", ;
		Top = 50
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfWizard.Basepage3.Choosetargetdb' AS choosetargetdb WITH ;
		Left = 160, ;
		Name = "Choosetargetdb", ;
		Top = 100, ;
		cboDatabases.Name = "cboDatabases", ;
		cboDatabases.ZOrderSet = 0, ;
		lblDBExists.Name = "lblDBExists", ;
		lblDBExists.ZOrderSet = 3, ;
		lblDescription.Name = "lblDescription", ;
		lblDescription.ZOrderSet = 2, ;
		opgNewOrExisting.baseoptionbutton1.Left = 5, ;
		opgNewOrExisting.baseoptionbutton1.Name = "baseoptionbutton1", ;
		opgNewOrExisting.baseoptionbutton1.Top = 5, ;
		opgNewOrExisting.baseoptionbutton2.Left = 5, ;
		opgNewOrExisting.baseoptionbutton2.Name = "baseoptionbutton2", ;
		opgNewOrExisting.baseoptionbutton2.Top = 23, ;
		opgNewOrExisting.Name = "opgNewOrExisting", ;
		opgNewOrExisting.ZOrderSet = 1, ;
		txtNewDatabaseName.Name = "txtNewDatabaseName", ;
		txtNewDatabaseName.ZOrderSet = 4
		*< END OBJECT: ClassLib="upswiz.vcx" BaseClass="container" />

	ADD OBJECT 'pgfWizard.Basepage3.Image1' AS baseimage WITH ;
		Height = 124, ;
		Left = 10, ;
		Name = "Image1", ;
		Picture = ..\bitmap\upsize45.bmp, ;
		Top = 20, ;
		Width = 139
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'pgfWizard.Basepage3.Label2' AS baselabel WITH ;
		Caption = "Select a database on the remote server that you want to upsize to, or click New and name the new database.", ;
		Left = 160, ;
		Name = "Label2", ;
		Top = 50, ;
		Width = 530
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfWizard.Basepage4.Cfieldtypemap' AS cfieldtypemap WITH ;
		Left = 300, ;
		Name = "Cfieldtypemap", ;
		Top = 170, ;
		cmdReset.Name = "cmdReset", ;
		grdTypeMap.grcFldName.Header1.Name = "Header1", ;
		grdTypeMap.grcFldName.Name = "grcFldName", ;
		grdTypeMap.grcRmtLength.Header1.Name = "Header1", ;
		grdTypeMap.grcRmtLength.Name = "grcRmtLength", ;
		grdTypeMap.grcRmtLength.txtLength.Name = "txtLength", ;
		grdTypeMap.grcRmtNull.Check1.Alignment = 0, ;
		grdTypeMap.grcRmtNull.Check1.Name = "Check1", ;
		grdTypeMap.grcRmtNull.Header1.Name = "Header1", ;
		grdTypeMap.grcRmtNull.Name = "grcRmtNull", ;
		grdTypeMap.grcRmtPrec.Header1.Name = "Header1", ;
		grdTypeMap.grcRmtPrec.Name = "grcRmtPrec", ;
		grdTypeMap.grcRmtPrec.txtPrecision.Name = "txtPrecision", ;
		grdTypeMap.grcRmtType.cboDataTypes.Name = "cboDataTypes", ;
		grdTypeMap.grcRmtType.Header1.Name = "Header1", ;
		grdTypeMap.grcRmtType.Name = "grcRmtType", ;
		grdTypeMap.grcType.Header1.Name = "Header1", ;
		grdTypeMap.grcType.Name = "grcType", ;
		grdTypeMap.Name = "grdTypeMap"
		*< END OBJECT: ClassLib="upswiz.vcx" BaseClass="container" />

	ADD OBJECT 'pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcFldName.Basetextbox1' AS basetextbox WITH ;
		Name = "Basetextbox1"
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcFldName.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcType.Basetextbox1' AS basetextbox WITH ;
		Name = "Basetextbox1"
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="textbox" />

	ADD OBJECT 'pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcType.Text1' AS textbox WITH ;
		BackColor = 255,255,255, ;
		BorderStyle = 0, ;
		FontName = "Tahoma", ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Margin = 0, ;
		Name = "Text1"
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'pgfWizard.Basepage4.cTableList' AS ctablelist WITH ;
		ctablenamefield = TblName, ;
		Left = 10, ;
		Name = "cTableList", ;
		Top = 155, ;
		chkIdentAdd.Alignment = 0, ;
		chkIdentAdd.Name = "chkIdentAdd", ;
		chkTables.Alignment = 0, ;
		chkTables.Name = "chkTables", ;
		chkTStampAdd.Alignment = 0, ;
		chkTStampAdd.Name = "chkTStampAdd", ;
		chkViews.Alignment = 0, ;
		chkViews.Name = "chkViews", ;
		cmdDeselectAll.Name = "cmdDeselectAll", ;
		cmdSelectAll.Name = "cmdSelectAll", ;
		grdTable.Column1.Check1.Alignment = 2, ;
		grdTable.Column1.Check1.Name = "Check1", ;
		grdTable.Column1.Header1.Name = "Header1", ;
		grdTable.Column1.Name = "Column1", ;
		grdTable.Column2.Header1.Name = "Header1", ;
		grdTable.Column2.Name = "Column2", ;
		grdTable.Column2.Text1.Name = "Text1", ;
		grdTable.COLUMN3.Check1.Alignment = 2, ;
		grdTable.COLUMN3.Check1.Name = "Check1", ;
		grdTable.COLUMN3.Header1.Name = "Header1", ;
		grdTable.COLUMN3.Name = "COLUMN3", ;
		grdTable.COLUMN4.Check1.Alignment = 2, ;
		grdTable.COLUMN4.Check1.Name = "Check1", ;
		grdTable.COLUMN4.Header1.Name = "Header1", ;
		grdTable.COLUMN4.Name = "COLUMN4", ;
		grdTable.Name = "grdTable"
		*< END OBJECT: ClassLib="upswiz.vcx" BaseClass="container" />

	ADD OBJECT 'pgfWizard.Basepage4.Image1' AS baseimage WITH ;
		Height = 124, ;
		Left = 10, ;
		Name = "Image1", ;
		Picture = ..\bitmap\upsize45.bmp, ;
		Top = 20, ;
		Width = 139
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'pgfWizard.Basepage4.Label1' AS baselabel WITH ;
		Caption = "Do you want to change the default mapping from local data types to server data types?", ;
		Left = 300, ;
		Name = "Label1", ;
		Top = 152
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfWizard.Basepage4.Label2' AS baselabel WITH ;
		Caption = "Which tables do you want to upsize to the target database?", ;
		Left = 160, ;
		Name = "Label2", ;
		Top = 50
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfWizard.Basepage5.ExportOptions' AS exportoptions WITH ;
		Left = 160, ;
		Name = "ExportOptions", ;
		TabIndex = 4, ;
		Top = 80, ;
		ZOrderSet = 1, ;
		Baselabel1.Name = "Baselabel1", ;
		Baseshape1.Name = "Baseshape1", ;
		Baseshape2.Name = "Baseshape2", ;
		chkBlankDates.Alignment = 0, ;
		chkBlankDates.Name = "chkBlankDates", ;
		chkBulkInsert.Alignment = 0, ;
		chkBulkInsert.Name = "chkBulkInsert", ;
		chkDefaults.Alignment = 0, ;
		chkDefaults.Name = "chkDefaults", ;
		chkExportDRI.Alignment = 0, ;
		chkExportDRI.Name = "chkExportDRI", ;
		chkIndexes.Alignment = 0, ;
		chkIndexes.Name = "chkIndexes", ;
		chkRelations.Alignment = 0, ;
		chkRelations.Name = "chkRelations", ;
		chkRemotizeViews.Alignment = 0, ;
		chkRemotizeViews.Name = "chkRemotizeViews", ;
		chkReport.Alignment = 0, ;
		chkReport.Name = "chkReport", ;
		chkSavePwd.Alignment = 0, ;
		chkSavePwd.Name = "chkSavePwd", ;
		chkStructureOnly.Alignment = 0, ;
		chkStructureOnly.Name = "chkStructureOnly", ;
		chkTableToView.Alignment = 0, ;
		chkTableToView.Name = "chkTableToView", ;
		chkValidation.Alignment = 0, ;
		chkValidation.Name = "chkValidation", ;
		cmdAdvanced.Name = "cmdAdvanced", ;
		cmdReportDir.Name = "cmdReportDir", ;
		Combo1.Name = "Combo1", ;
		lblReportDir.Name = "lblReportDir", ;
		lblReportOptions.Name = "lblReportOptions", ;
		txtReportDir.Name = "txtReportDir", ;
		Wizlabel1.Name = "Wizlabel1", ;
		Wizlabel2.Name = "Wizlabel2", ;
		Wizlabel3.Name = "Wizlabel3", ;
		Wizshape1.Name = "Wizshape1", ;
		Wizshape2.Name = "Wizshape2"
		*< END OBJECT: ClassLib="upswiz.vcx" BaseClass="container" />

	ADD OBJECT 'pgfWizard.Basepage5.Image1' AS baseimage WITH ;
		Height = 124, ;
		Left = 10, ;
		Name = "Image1", ;
		Picture = ..\bitmap\upsize9.bmp, ;
		Top = 20, ;
		Width = 139, ;
		ZOrderSet = 2
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'pgfWizard.Basepage5.Label1' AS baselabel WITH ;
		Caption = "Which upsizing options do you want to set?", ;
		Left = 160, ;
		Name = "Label1", ;
		TabIndex = 3, ;
		Top = 50, ;
		ZOrderSet = 3
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfWizard.Basepage6.Image1' AS baseimage WITH ;
		Height = 161, ;
		Left = 10, ;
		Name = "Image1", ;
		Picture = ..\bitmap\flag.bmp, ;
		Top = 20, ;
		Width = 105
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="image" />

	ADD OBJECT 'pgfWizard.Basepage6.Label2' AS baselabel WITH ;
		Caption = "You are ready to upsize your data. Select an option and click Finish.", ;
		Left = 160, ;
		Name = "Label2", ;
		TabIndex = 1, ;
		Top = 50
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="label" />

	ADD OBJECT 'pgfWizard.Basepage6.opgOutputType' AS baseoptiongroup WITH ;
		ButtonCount = 3, ;
		Height = 61, ;
		Left = 160, ;
		Name = "opgOutputType", ;
		TabIndex = 2, ;
		Top = 70, ;
		Value = 1, ;
		Width = 183, ;
		baseoptionbutton1.Caption = "\<Upsize", ;
		baseoptionbutton1.Left = 5, ;
		baseoptionbutton1.Name = "baseoptionbutton1", ;
		baseoptionbutton1.Top = 5, ;
		baseoptionbutton1.Value = 1, ;
		baseoptionbutton2.Caption = "\<Save generated SQL", ;
		baseoptionbutton2.Left = 5, ;
		baseoptionbutton2.Name = "baseoptionbutton2", ;
		baseoptionbutton2.Top = 23, ;
		Baseoptionbutton3.Caption = "Upsize \<and save generated SQL", ;
		Baseoptionbutton3.Left = 5, ;
		Baseoptionbutton3.Name = "Baseoptionbutton3", ;
		Baseoptionbutton3.Top = 40
		*< END OBJECT: ClassLib="basecontrols.vcx" BaseClass="optiongroup" />

	ADD OBJECT 'pgfWizard.Basepage6.oProgress' AS progressbar WITH ;
		Left = 168, ;
		Name = "oProgress", ;
		TabIndex = 6, ;
		Top = 190, ;
		Visible = .F., ;
		lblTask.Name = "lblTask", ;
		LBLTITLE.Name = "LBLTITLE", ;
		oProgress.Name = "oProgress"
		*< END OBJECT: ClassLib="upswiz.vcx" BaseClass="container" />
	
	PROCEDURE analysiscleanup		&& Clean up analysis tables
		with This.pgfWizard.BasePage4
			.cTableList.cRecordSourceAlias = ''
			.cFieldTypeMap.cRecordsource   = ''
		endwith
		This.oEngine.AnalCleanUp('Delete')
		This.oEngine.SourceDB = ''
		
	ENDPROC

	PROCEDURE checkdestination		&& Determines if the destination information is complete
		local llReturn
		with This
			do case
				case .nConnectionType = 1
					llReturn = not empty(.cConnectionDatabase) and ;
						not empty(.cConnection)
				case .nODBCType = 1
					llReturn = not empty(.cDSN)
				case .nODBCType = 2
					llReturn = not empty(.cServer)
				otherwise
					llReturn = not empty(.cConnString)
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE completeprocess		&& Completes the progress bar for a process
		This.pgfWizard.BasePage6.oProgress.CompleteProcess()
		
	ENDPROC

	PROCEDURE finish
		with This
			.oEngine.NormalShutdown   = .T.
			.oEngine.NotUseBulkInsert = not .lUseBulkInsert
			bindevent(.oEngine, 'InitProcess',     This, 'InitProcess')
			bindevent(.oEngine, 'UpdateProcess',   This, 'UpdateProcess')
			bindevent(.oEngine, 'CompleteProcess', This, 'CompleteProcess')
			.oEngine.ProcessOutput()
		endwith
		This.Release()
		
	ENDPROC

	PROCEDURE initprocess		&& Initialize the progress bar for a process
		lparameters tcTitle, tnBasis
		This.pgfWizard.BasePage6.oProgress.InitProcess(tcTitle, tnBasis)
		
	ENDPROC

	PROCEDURE Load
		* Open the libraries we need.
		
		local laCallStack[1], ;
			lcProgram, ;
			llApp, ;
			lcMain, ;
			lcFFLLocation, ;
			loException as Exception, ;
			lcMessage, ;
			lcPath
		dodefault()
		
		* Load the FLL.
		
		astackinfo(laCallStack)
		lcProgram     = laCallStack[program(-1) - 1, 2]
		llApp         = upper(justext(lcProgram)) = 'APP'
		lcMain        = addbs(justpath(iif(llApp, lcProgram, ;
			fullpath(justpath(lcProgram) + '\..\'))))
		lcFFLLocation = lcMain + 'UPSWIZ.FLL'
		if file(lcFFLLocation)
			try 
				set library to (lcFFLLocation) additive
			catch to loException
				lcMessage = 'The Upsizing Wizard could not load UPSWIZ.FLL. The ' + ;
					'error message is:' + chr(13) + chr(13) + loException.Message
			endtry
		else
			lcMessage = lcFFLLocation + ' cannot be located.'
		endif file(lcFFLLocation)
		
		* If we're running this as a standalone form, set the path.
		
		if not llApp
			This.cPath = set('PATH')
			lcPath = lcMain + 'program,' + lcMain + 'data,' + lcMain + 'lib'
			set path to '&lcPath' additive
		endif not llApp
		
		* Load the procedure files.
		
		if empty(lcMessage)
			try
				set procedure to upswzfunc, wizusz, wzengine additive
			catch to loException
				lcMessage = 'The Upsizing Wizard could not load its procedures. ' + ;
					'The error message is:' + chr(13) + chr(13) + loException.Message
			endtry
		endif empty(lcMessage)
		if empty(lcMessage)
			try 
				This.oEngine = createobject('UpsizeEngine')
				This.oEngine.ServerType = SQL_Server
				This.oEngine.SQLServer  = .T.
			catch to loException
				lcMessage = loException.Message
			endtry
		endif empty(lcMessage)
		
		* Display an error message and bug out if something went wrong.
		
		if not empty(lcMessage)
			messagebox(lcMessage, 0, This.Caption)
		endif not empty(lcMessage)
		return empty(lcMessage)
		
	ENDPROC

	PROCEDURE releasemembers
		local lcPath
		
		* Nuke the engine object.
		
		This.oEngine = .NULL.
		
		* Restore the path.
		
		lcPath = This.cPath
		set path to &lcPath
		
	ENDPROC

	PROCEDURE setsourcedatabase		&& Sets cSourceDatabase to the specified value
		lparameters tcDatabase
		if vartype(tcDatabase) = 'C' and not empty(tcDatabase) and file(tcDatabase)
			try
				open database (tcDatabase) exclusive
				This.cSourceDatabase = tcDatabase
			catch to loException when loException.ErrorNo = 1705
				messagebox(tcDatabase + ' cannot be opened exclusively.', 48, ;
					This.Caption)
			catch to loException
				messagebox(tcDatabase + ' cannot be opened.', 48, This.Caption)
			endtry
		endif vartype(tcDatabase) = 'C' ...
		
	ENDPROC

	PROCEDURE setupsteps
		with This
			.aSteps[1, 1] = 'Step 1 - Select Local Database'
			.aSteps[1, 2] = 'not empty(Thisform.cSourceDatabase)'
			.aSteps[1, 4] = '.T.'
		
			.aSteps[2, 1] = 'Step 2 - Select Destination'
			.aSteps[2, 2] = 'Thisform.CheckDestination()'
			.aSteps[2, 4] = '.T.'
		
			.aSteps[3, 1] = 'Step 3 - Select Target Database'
			.aSteps[3, 2] = 'not empty(iif(Thisform.nDatabaseType = 1, ' + ;
				'Thisform.cTargetDatabase, Thisform.cNewTargetDatabase)) and ' + ;
				'Thisform.lTargetDatabaseValid'
			.aSteps[3, 4] = '.T.'
		
			.aSteps[4, 1] = 'Step 4 - Choose Tables and Map Field Data Types'
			.aSteps[4, 2] = 'Thisform.lTableChosen'
			.aSteps[4, 4] = '.T.'
		
			.aSteps[5, 1] = 'Step 5 - Set Upsizing Options'
			.aSteps[5, 2] = '.T.'
			.aSteps[5, 4] = '.T.'
		
			.aSteps[6, 1] = 'Step 6 - Finish'
			.aSteps[6, 2] = '.T.'
			.aSteps[6, 4] = '.T.'
		endwith
		dodefault()
		
	ENDPROC

	PROCEDURE stepdone
		lparameters tnStep
		local llReturn, ;
			lcDataBase, ;
			lnOldWorkArea, ;
			laDummy[1], ;
			lcOldConnStr, ;
			lcConnectionStr, ;
			llNewConnection
		with This.pgfWizard
			llReturn = .T.
			do case
		
		* See if the user changed databases from their original selection. If so, we
		* need to reload things.
		
				case tnStep = 1
					lcDataBase = This.cSourceDatabase
					if not This.oEngine.SourceDB == lcDataBase
						llReturn = .BasePage1.ChooseSourceDB.ReallyChangeSourceDB()
						if llReturn
							lnOldWorkArea = select()
							This.oEngine.SourceDB = lcDataBase
							This.oEngine.AnalyzeTables()
							select (This.oEngine.EnumTablesTbl)
							replace all Type with 'T', ;
								EXPORT with not upper(alltrim(TblName)) == "UPZMSG"
							This.lNeedReloadFields = .T.
							locate
							select (lnOldWorkArea)
						endif llReturn
					endif not This.oEngine.SourceDB == lcDataBase
					if llReturn
						select TblName from (This.oEngine.EnumTablesTbl) ;
							where Type ="T" into array laDummy 
						if _tally = 0
							messagebox('There are no tables in the selected ' + ;
								'database for upsizing.', 48, Thisform.Caption)
							llReturn = .F.
						endif _tally = 0
					endif llReturn
		
		* Once the data source has been selected, try to connect to it.
		
				case tnStep = 2
					lcOldConnStr    = .BasePage2.cConnStr.cOldConnStr
					lcConnectionStr = .BasePage2.cConnStr.GetConnStr()
					llNewConnection = not upper(alltrim(lcOldConnStr)) == upper(alltrim(lcConnectionStr))
					if llNewConnection
						if not empty(lcOldConnStr)
							llReturn = .BasePage2.cConnStr.LogOff()
						endif not empty(lcOldConnStr)
						llReturn = llReturn and .BasePage2.cConnStr.LogOn()
						llReturn = llReturn and .BasePage3.ChooseTargetDB.SelfFill()
					endif llNewConnection
			
		* Once a target database has been chosen, ensure it's valid and handle it.
		
				case tnStep = 3
					if not empty(iif(Thisform.nDatabaseType = 1, ;
						Thisform.cTargetDatabase, Thisform.cNewTargetDatabase))
						if .BasePage3.ChooseTargetDB.IsValid()
							if This.oEngine.ServerType <> ORACLE_SERVER
								.BasePage3.ChooseTargetDB.MoveForward()
							endif This.oEngine.ServerType <> ORACLE_SERVER
							This.oEngine.CreateNewDB = This.nDatabaseType = 2
							if This.oEngine.CreateNewDB
								This.oEngine.ServerDBName = This.cNewTargetDatabase
							else
								This.oEngine.ServerDBName = This.cTargetDatabase
							endif This.oEngine.CreateNewDB
							.BasePage5.ExportOptions.SetOptions()
							if This.lNeedReloadFields
								lnOldWorkArea = select()
								This.oEngine.AnalyzeFields(.T.)
								.BasePage4.cTableList.cRecordSourceAlias = This.oEngine.EnumTablesTbl
								.BasePage4.cFieldTypeMap.cRecordSource   = This.oEngine.EnumFieldsTbl
								This.oEngine.ReadViews()
								This.lNeedReloadFields = .F.
								select (lnOldWorkArea)
								This.lTableChosen = .BasePage4.cTablelist.CheckForChoosen()
								This.RefreshSteps()
							endif This.lNeedReloadFields
						endif .BasePage3.ChooseTargetDB.IsValid()
					endif not empty(iif(Thisform.nDatabaseType = 1 ...
		
		* If we're leaving step 4, flag whether a table was chosen or not.
		
				case tnStep = 4
					This.lTableChosen = .BasePage4.cTablelist.CheckForChoosen()
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE updateprocess		&& Update the progress bar for a process
		lparameters tnProgress, tcTask
		This.pgfWizard.BasePage6.oProgress.UpdateProcess(tnProgress, tcTask)
		
	ENDPROC

	PROCEDURE pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcFldName.Basetextbox1.LostFocus
		This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
	ENDPROC

	PROCEDURE pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcRmtLength.txtLength.LostFocus
		This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
	ENDPROC

	PROCEDURE pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcRmtPrec.txtPrecision.LostFocus
		This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
	ENDPROC

	PROCEDURE pgfWizard.Basepage4.Cfieldtypemap.grdTypeMap.grcType.Basetextbox1.LostFocus
		This.Value = CHRTRAN(This.Value, CHR(13) + CHR(10) , "")
	ENDPROC

	PROCEDURE pgfWizard.Basepage4.cTableList.grdTable.AfterRowColChange
		LPARAMETERS nColIndex
		
		LOCAL m.lnOldWorkArea as Integer
		
		m.lnOldWorkArea = SELECT()
		
		WITH This.Parent.Parent.cFieldTypeMap
			IF !EMPTY(.grdTypeMap.RecordSource) AND USED(.grdTypeMap.RecordSource)
				SELECT(.grdTypeMap.RecordSource)
				LOCATE
			ENDIF
		
			.grdTypeMap.Refresh()
		ENDWITH 
		
		SELECT(m.lnOldWorkArea)
	ENDPROC

	PROCEDURE pgfWizard.Basepage6.opgOutputType.InteractiveChange
		do case
			case This.Value = 1
				Thisform.oEngine.DoUpsize  = .T.
				Thisform.oEngine.DoScripts = .F.
			case This.Value = 2
				Thisform.oEngine.DoUpsize  = .F.
				Thisform.oEngine.DoScripts = .T.
			case This.Value = 3
				Thisform.oEngine.DoUpsize  = .T.
				Thisform.oEngine.DoScripts = .T.
		endcase
		
	ENDPROC

ENDDEFINE
